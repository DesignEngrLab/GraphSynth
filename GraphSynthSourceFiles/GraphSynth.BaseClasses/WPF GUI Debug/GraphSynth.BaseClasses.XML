<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GraphSynth.BaseClasses</name>
    </assembly>
    <members>
        <member name="T:GraphSynth.BasicFiler">
            <summary>
              This method saves and opens basic graphs and rules (doesn't include WPF shapes)
              as well as rulesets, which are the same as in earlier versions of GraphSynth.
            </summary>
        </member>
        <member name="F:GraphSynth.BasicFiler.IgnorablePrefix">
            <summary>
              This constant is used to tell other XML parsers (namely XAML displayers)
              to ignore elements that are prefaced with this.
            </summary>
        </member>
        <member name="M:GraphSynth.BasicFiler.#ctor(System.String,System.String,System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.BasicFiler"/> class.
            </summary>
            <param name="iDir">The input directory.</param>
            <param name="oDir">The output directory.</param>
            <param name="rDir">The rules directory.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.Save(System.String,System.Object,System.Boolean)">
            <summary>
              Saves the object, o, to the specified filename.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "o">The object to save.</param>
            <param name = "SuppressWarnings">if set to <c>true</c> [suppress warnings].</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.Open(System.String,System.Boolean)">
            <summary>
              Opens the list of objects at the specified filename.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "SuppressWarnings">if set to <c>true</c> [suppresses warnings].</param>
            <returns>an array of opened objects</returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveGraph(System.String,GraphSynth.Representation.designGraph)">
            <summary>
              Saves the graph.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "graph1">The graph1.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SerializeGraphToXml(GraphSynth.Representation.designGraph)">
            <summary>
              Serializes the graph to XML.
            </summary>
            <param name = "graph1">The graph1.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenGraph(System.String)">
            <summary>
              Opens the graph.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.DeSerializeGraphFromXML(System.String)">
            <summary>
              Deserialize graph from XML.
            </summary>
            <param name = "xmlString">The XML string.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.RestoreDisplayShapes(GraphSynth.Representation.designGraph)">
            <summary>
              Restores the display shapes.
            </summary>
            <param name = "graph">The graph.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveRule(System.String,GraphSynth.Representation.grammarRule)">
            <summary>
              Saves the rule.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "ruleToSave">The rule to save.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SerializeRuleToXml(GraphSynth.Representation.grammarRule)">
            <summary>
              Serializes the rule to XML.
            </summary>
            <param name = "ruleToSave">The rule to save.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenRule(System.String)">
            <summary>
              Opens the rule.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.DeSerializeRuleFromXML(System.String)">
            <summary>
              Deserialize rule from XML.
            </summary>
            <param name = "xmlString">The XML string.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.checkRule(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks the rule with some issues that may have been overlooked.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.NotExistElementsinKR(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks to see that the negative elements are not stored in K and R.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.KarcsChangeDirection(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks that the K arcs do not change direction.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.NumKElements(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks that the number of K elements is greater than 0.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.ValidateFreeArcEmbeddingRules(GraphSynth.Representation.grammarRule)">
            <summary>
            Validates the free arc embedding rules.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveRuleSet(System.String,GraphSynth.Representation.ruleSet)">
            <summary>
              Saves the rule set.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "ruleSetToSave">The rule set to save.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenRuleSet(System.String)">
            <summary>
              Opens the rule set.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.LoadRulesFromFileNames(System.String,System.Collections.Generic.List{System.String},System.Int32@)">
            <summary>
              Loads the rules from file names.
            </summary>
            <param name = "ruleDir">The rule dir.</param>
            <param name = "ruleFileNames">The rule file names.</param>
            <param name = "numLoaded">The num loaded.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.ReloadSpecificRule(GraphSynth.Representation.ruleSet,System.Int32)">
            <summary>
              Reloads the specific rule.
            </summary>
            <param name = "rs">The rs.</param>
            <param name = "i">The i.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveCandidates(System.String,System.Collections.IList,System.Boolean,System.Boolean)">
            <summary>
            Saves the candidate.
            </summary>
            <param name="filename">The filename.</param>
            <param name="candidates">The candidates.</param>
            <param name="SaveToOutputDir">if set to <c>true</c> [save to output dir].</param>
            <param name="timeStamp">if set to <c>true</c> [time stamp].</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveCandidate(System.String,GraphSynth.Representation.candidate)">
            <summary>
              Saves the candidate.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "c1">The c1.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenCandidate(System.String)">
            <summary>
              Opens the candidate.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.BasicFiler.inputDirectory">
            <summary>
              Gets or sets the input directory.
            </summary>
            <value>The input directory.</value>
        </member>
        <member name="P:GraphSynth.BasicFiler.outputDirectory">
            <summary>
              Gets or sets the output directory.
            </summary>
            <value>The output directory.</value>
        </member>
        <member name="P:GraphSynth.BasicFiler.rulesDirectory">
            <summary>
              Gets or sets the rules directory.
            </summary>
            <value>The rules directory.</value>
        </member>
        <member name="T:GraphSynth.Representation.arc">
            <summary>
              One of the two basic classes for a graph is the arc or edge that connects
              two and only two elements of the node class.
            </summary>
        </member>
        <member name="T:GraphSynth.Representation.graphElement">
            <summary>
              The base class of node, arc, and hyperarc. It simply captures the basic
              qualities that all includes - mainly a list of labels.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.graphElement._localLabels">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.graphElement._localVariables">
            <summary />
        </member>
        <member name="M:GraphSynth.Representation.graphElement.copy(GraphSynth.Representation.graphElement)">
            <summary>
              Copies this graphElement data into the copyOfElt.
            </summary>
            <param name = "copyOfElt">The copy of elt.</param>
        </member>
        <member name="M:GraphSynth.Representation.graphElement.setLabel(System.Int32,System.String)">
            <summary>
              Sets the label. The following two functions are not properties, but work on 
              a similar philosophy. These are like the f0, f1, etc. properties in candidate.
              Here we want to set a label but we are unsure whether the list of local labels
              is long enough. The while loop insures that there are enough items of list, 
              before adding the label. */
            </summary>
            <param name = "index">The index.</param>
            <param name = "label">The label.</param>
        </member>
        <member name="M:GraphSynth.Representation.graphElement.setVariable(System.Int32,System.Double)">
            <summary>
              Sets the variable. Like the function above, here we want to set a variable but 
              we are unsure whether the list of local labels is long enough. The while loop 
              insures that there are enough items of list, before adding the label.
            </summary>
            <param name = "index">The index.</param>
            <param name = "var">The var.</param>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.name">
            <summary>
              Gets or sets the name of the node or arc. All names must be distinct 
              within a given graph in order to correctly serialize and de-
              serialize the graph from the XML (*.gxml) file.
            </summary>
            <value>The name string.</value>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.extraData">
            <summary>
              Gets or sets the old data. In order to be compatible with previous versions,
              this oldData object will be used to catch old files that use screenX and 
              screenY instead of the new format.
            </summary>
            <value>The old data.</value>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.DisplayShape">
            <summary>
              Gets or sets the display shape.
            </summary>
            <value>The display shape.</value>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.localLabels">
            <summary>
              Gets the local labels.
            </summary>
            <value>The local labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.localVariables">
            <summary>
              Gets the local variables.
            </summary>
            <value>The local variables.</value>
        </member>
        <member name="F:GraphSynth.Representation.arc.from">
            <summary>
              Each arc connects to two and only two nodes, these are stored in protected elements.
              This is a field for the node the arc is coming from.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.arc.to">
            <summary>
              Each arc connects to two and only two nodes, these are stored in protected elements.
              This is a field for the node the arc is going to.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.arc.otherNode(GraphSynth.Representation.node)">
            <summary>
              Given one connecting node, this function returns
              the other node connected to this arc.
            </summary>
            <param name = "node1">One known node.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.arc.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.arc"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.arc.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.arc"/> class.
            </summary>
            <param name="newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.arc.copy">
            <summary>
              Copies this instance of an arc and returns the copy.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.arc.copy(GraphSynth.Representation.arc)">
            <summary>
              Copies this.arc into the argument copyOfArc.
            </summary>
            <param name = "copyOfArc">The copy of arc.</param>
        </member>
        <member name="P:GraphSynth.Representation.arc.From">
            <summary>
              Gets or sets the connected node, From.
            </summary>
            <value>the node the arc is coming from.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.To">
            <summary>
              Gets or sets  the connected node, To.
            </summary>
            <value>the node the arc is going to.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.XmlFrom">
            <summary>
              Gets or sets the name of the node that the arc is coming from.
              It is necessary to do this, otherwise the serializer would rewrite 
              the actual node to the file (*.gxml file).
            </summary>
            <value>The XML from.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.XmlTo">
            <summary>
              Gets or sets the  NAME of the node that the arc is going to.
            </summary>
            <value>The XML to.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.directed">
            <summary>
              Gets or sets a value indicating whether this <see cref="T:GraphSynth.Representation.arc"/> is directed.
            </summary>
            <value><c>true</c> if directed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.doublyDirected">
            <summary>
              Gets or sets a value indicating whether [doubly directed].
            </summary>
            <value><c>true</c> if [doubly directed]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.length">
            <summary>
              Gets the straightline distance between the two connecting nodes.
            </summary>
            <value>The length.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.arcType">
            <summary>
              Gets or sets the type of the arc.
            </summary>
            <value>The type of the arc.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.XmlArcType">
            <summary>
              Gets or sets the type of the XML string correspong to the type of arc.
            </summary>
            <value>The string describing the type of arc.</value>
        </member>
        <member name="T:GraphSynth.Representation.edge">
            <summary>
              Originally, I created a separate edge and vertex class to allow for the future expansion
              of GraphSynth into shape grammars. I now have decided that the division is not useful, 
              since it simply deprived nodes of X,Y,Z positions. Many consider edge and arc, and vertex
              and node to be synonymous anyway but I prefer to think of edges and vertices as arcs and 
              nodes with spatial information. At any rate there is no need to have these inherited 
              classes, but I keep them for backwards-compatible purposes.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.edge.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.edge"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:GraphSynth.Representation.edge.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.edge"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.edge.copy">
            <summary>
              Copies this instance of an arc and returns the copy.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="T:GraphSynth.Representation.candidate">
            <summary>
              The candidate class is a wrapper to designGraph. While the graph is
              essentially what we are interested in, the candidate also includes
              some other essential information. For example, what is the worth
              of the graph (performance parameters), and what is the recipe, or
              list of options that were called to create the graph (recipe).
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.candidate"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.#ctor(GraphSynth.Representation.designGraph,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.candidate"/> class.
            </summary>
            <param name="_graph">The _graph.</param>
            <param name="numRuleSets">The num rule sets.</param>
        </member>
        <member name="F:GraphSynth.Representation.candidate.prevStates">
            <summary>
              currently we store all the previous states of a candidate. This makes candidate a
              'heavy' class, but it allows us to go back to how it existed quickly.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.candidate.GenerationStatus">
            <summary>
              Just like the discussion for activeRuleSetIndex, GenerationStatus stores what has
              happened during the RCA generation loop. The is one for each ruleSet as each ruleSet
              may have ended in a different way.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.candidate.performanceParams">
            <summary>
              a list of numbers used to define a candidate's worth. While this is a public field, 
              it may be less buggy to write code using the properties f0, f1, f2, f3, and f4 stored
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.candidate.recipe">
            <summary>
              the recipe is a list of all the options that were chosen to create the candidate.
              Option is stored under representation. Each option contains, the rulesetindex,
              the number of the rule, a reference to the rule, and the location of where the rule
              was applied.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.candidate.designParameters">
            <summary>
              a list of numbers used to define a candidate's design or decision variable. This is
              typically used to define parameters within the graph.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.saveCurrent">
            <summary>
              Saves a copy of the current state to the list of previous states.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.addToRecipe(GraphSynth.Representation.option)">
            <summary>
              Adds to recipe. This is called (currently only) from the RCA loop. This happens
              directly after the rule is APPLIED. A rule application updates
              the currentstate, so this correspondingly adds the option to the recipe.
            </summary>
            <param name = "currentOpt">The currentrule.</param>
        </member>
        <member name="M:GraphSynth.Representation.candidate.undoLastRule">
            <summary>
              Undoes the last rule. This is perhaps the whole reason previous states are used.
              Rules cannot be guaranteed to work in reverse as they work
              forward, so this simply resets the candidate to how it looked
              prior to calling the last rule.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.copy">
            <summary>
              Copies this instance of a candidate. Very similar to designGraph copy.
              We make sure to not do a shallow copy (ala Clone) since we are unsure
              how each candidate may be changed in the future.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.candidate.graph">
            <summary>
              Gets or sets the graph. Stating a candidate's graph is simply it's current state. 
              However, if this property is used in to set the graph to a new one, then we move 
              the current state onto the prevStates list.
            </summary>
            <value>The graph.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.graphFileName">
            <summary>
              Gets or sets the name of the graph file.
            </summary>
            <value>The name of the graph file.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.activeRuleSetIndex">
            <summary>
              Gets or sets the index of the active rule set. the activeRuleSetIndex is set during 
              the recognize->choose->apply generation. It is very similar to the candidate property, 
              lastRuleSetIndex however in certain subtle yet important occasions the two will differ. 
              This will happen if an RCA loop starts but doesn't complete apply. This happens if 
              max number of calls is reached, if choice is STOP, or no rules are recognized.
            </summary>
            <value>The index of the active rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.age">
            <summary>
              Gets or sets the age. This is an arbitrary value set by the search process. 
              Likely it will be set to the # of iterations the candidate has existed in.
            </summary>
            <value>The age.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.numRulesCalled">
            <summary>
              Gets the number of rules called (same of length of recipe.
            </summary>
            <value>The num rules called.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.lastRuleSetIndex">
            <summary>
              Gets the rule set index of the last option.
            </summary>
            <value>The last index of the rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f0">
            <summary>
              Gets or sets the first performance parameter.
            </summary>
            <value>The f0.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f1">
            <summary>
              Gets or sets the second performance parameter.
            </summary>
            <value>The f1.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f2">
            <summary>
              Gets or sets the third performance parameter.
            </summary>
            <value>The f2.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f3">
            <summary>
              Gets or sets the fourth performance parameter.
            </summary>
            <value>The f3.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f4">
            <summary>
              Gets or sets the fifth performance parameter.
            </summary>
            <value>The f4.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.ruleNumbersInRecipe">
            <summary>
              Gets the rule numbers in recipe as an array of integers.
            </summary>
            <value>The rule numbers in recipe.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.ruleSetIndicesInRecipe">
            <summary>
              Gets the rule set indices in recipe as an array of integers.
            </summary>
            <value>The rule set indices in recipe.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.optionNumbersInRecipe">
            <summary>
              Gets the option numbers in recipe as an array of integers.
            </summary>
            <value>The option numbers in recipe.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.parametersInRecipe">
            <summary>
              Gets the parameter decisions of the recipe. This is a List the
              same length as recipe, but each element is an array of double values.
            </summary>
            <value>The parameters in recipe.</value>
        </member>
        <member name="T:GraphSynth.Representation.designGraph">
            <summary>
              The quintessential class in all of this research. The graph of nodes,
              arcs, and hyperarcs is called a designGraph. The use of the word design
              is a carry-over from other research, but indicates that GraphSynth is really
              about designing with graphs.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.designGraph._globalLabels">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.designGraph._globalVariables">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.designGraph._arcs">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.designGraph._hyperarcs">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.designGraph._nodes">
            <summary />
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addArc(GraphSynth.Representation.node,GraphSynth.Representation.node,System.String,System.Type)">
            <summary>
              Creates and Adds a new arc to the graph, and connects it between
              the fromNode and the toNode
            </summary>
            <param name = "newName">The name.</param>
            <param name = "arcType">Type of the arc.</param>
            <param name = "fromNode">From node.</param>
            <param name = "toNode">To node.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addArc(GraphSynth.Representation.arc,GraphSynth.Representation.node,GraphSynth.Representation.node)">
            <summary>
              Adds the arc to the graph and connects it between these two nodes.
            </summary>
            <param name = "newArc">The new arc.</param>
            <param name = "fromNode">From node.</param>
            <param name = "toNode">To node.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addArc(GraphSynth.Representation.arc)">
            <summary>
            Adds the arc to the graph and connects it between these two nodes.
            </summary>
            <param name="newArc">The new arc.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.removeArc(GraphSynth.Representation.arc)">
            <summary>
              Removes the arc and references to it in the nodes.
            </summary>
            <param name = "arcToRemove">The arc to remove.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addNode(System.Type)">
            <summary>
              Creates and Adds a new node of type nodeType.
            </summary>
            <param name = "nodeType">Type of the node.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addNode(System.String,System.Type)">
            <summary>
              Creates and Adds a new node of called newName of type nodeType.
            </summary>
            <param name = "newName">The new name.</param>
            <param name = "nodeType">Type of the node.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addNode(GraphSynth.Representation.node)">
            <summary>
              Adds the node to the graph. This is very simple, and is in fact identical to
              doing graph.nodes.Add(n);
            </summary>
            <param name = "n">The n.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.removeNode(GraphSynth.Representation.node,System.Boolean)">
            <summary>
              Removes the node. Removing a node is a little more complicated than removing arcs
              since we need to decide what to do with dangling arcs. As a result there are two 
              booleans that specify how to handle the arcs. removeArcToo will simply delete the
              attached arcs if true, otherwise it will leave them dangling (default is false).
              removeNodeRef will change the references within the attached arcs to null if set 
              to true, or will leave them if false (default is true).
            </summary>
            <param name = "nodeToRemove">The node to remove.</param>
            <param name = "removeNodeRef">if set to <c>true</c> remove reference to this node in the arcs.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addHyperArc(System.Collections.Generic.List{GraphSynth.Representation.node},System.String,System.Type)">
            <summary>
            Creates and Adds a new hyperarc to the graph, and connects it
            to the stated nodes.
            </summary>
            <param name="attachedNodes">The nodes.</param>
            <param name="newName">The new name.</param>
            <param name="t">The t.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addHyperArc(GraphSynth.Representation.hyperarc,System.Collections.Generic.List{GraphSynth.Representation.node})">
            <summary>
            Adds the arc to the graph and connects it between these nodes.
            </summary>
            <param name="newArc">The new arc.</param>
            <param name="attachedNodes">The nodes.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.removeHyperArc(GraphSynth.Representation.hyperarc)">
            <summary>
            Removes the hyper arc.
            </summary>
            <param name="arcToRemove">The arc to remove.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.designGraph"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.#ctor(System.Collections.Generic.IEnumerable{GraphSynth.Representation.node},System.Collections.Generic.IEnumerable{GraphSynth.Representation.arc},System.Collections.Generic.IEnumerable{GraphSynth.Representation.hyperarc})">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.designGraph"/> class.
            currently this constructor is used within the recognize function of the
            grammar rule to establish each of the recognized locations.
            </summary>
            <param name="newNodes">The new nodes.</param>
            <param name="newArcs">The new arcs.</param>
            <param name="newHyperArcs">The new hyper arcs.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.CreateRandomGraph(System.Int32,System.Int32)">
            <summary>
            Creates a random graph that takes two parameters: the number of nodes, 
            and the average degree. Note: that there is no guarantee that the graph 
            will be connected.
            </summary>
            <param name = "numNodes">The number of nodes.</param>
            <param name = "aveDegree">The average degree.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.CreateCompleteGraph(System.Int32)">
            <summary>
              Creates a complete graph where every node is connected to every
              other node by an arc.
            </summary>
            <param name="numNodes">The number of nodes.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.CreateEmptyLocationGraph(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an empty location graph used in recognition.
            </summary>
            <param name="numNodes">The num nodes.</param>
            <param name="numArcs">The num arcs.</param>
            <param name="numHyperArcs">The num hyper arcs.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.copy(System.Boolean)">
            <summary>
              Copies the specified make deep copy.
            </summary>
            <param name = "MakeDeepCopy">if set to <c>true</c> [make deep copy].</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.makeUniqueNodeName(System.String)">
            <summary>
              Makes a unique name for a node.
            </summary>
            <param name = "stub">The stub.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.makeUniqueArcName(System.String)">
            <summary>
              Makes a unique name for an arc.
            </summary>
            <param name = "stub">The stub.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.makeUniqueHyperArcName(System.String)">
            <summary>
            Makes the name of the unique hyper arc.
            </summary>
            <param name="stub">The stub.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.internallyConnectGraph">
            <summary>
              Internally connects the graph.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.replaceNodeWithInheritedType(GraphSynth.Representation.node)">
            <summary>
              Replaces the type of the node with inherited.
            </summary>
            <param name = "origNode">The orig node.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.replaceArcWithInheritedType(GraphSynth.Representation.arc)">
            <summary>
            Replaces the type of the arc with inherited.
            </summary>
            <param name="origArc">The orig arc.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.replaceHyperArcWithInheritedType(GraphSynth.Representation.hyperarc)">
            <summary>
            Replaces the type of the arc with inherited.
            </summary>
            <param name="origArc">The orig arc.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.checkForRepeatNames">
            <summary>
              Checks for repeat names.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.name">
            <summary>
              Gets or sets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.comment">
            <summary>
              Gets or sets the comment.
            </summary>
            <value>The comment.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.globalLabels">
            <summary>
              Gets the global labels.
            </summary>
            <value>The global labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.globalVariables">
            <summary>
              Gets the global variables.
            </summary>
            <value>The global variables.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.arcs">
            <summary>
              Gets or sets the arcs.
            </summary>
            <value>The arcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.nodes">
            <summary>
              Gets the nodes.
            </summary>
            <value>The nodes.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.hyperarcs">
            <summary>
              Gets the hyperarcs.
            </summary>
            <value>The hyperarcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.DegreeSequence">
            <summary>
            Gets the degree sequence.
            </summary>
            <value>The degree sequence.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.HyperArcDegreeSequence">
            <summary>
            Gets the hyper arc degree sequence.
            </summary>
            <value>The hyper arc degree sequence.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.Item(System.String)">
            <summary>
              Gets the <see cref="T:GraphSynth.Representation.graphElement"/> with the specified name.
              This indexer is to make it easier to find a particular node, arc, or hyperArc. Note 
              that it only returns a graphElement, so the user must explicitly cast it as a node,
              arc, or hyperArc.
            </summary>
            <value></value>
        </member>
        <member name="T:GraphSynth.Representation.hyperarc">
            <summary>
              In the spring of 2010, it was decided to introduce a third basic element
              to the graph: a hyperarc. A hyperarc is an arc that connects an arbitrary
              number of nodes. It does not have a sense of direction like an arc (i.e. all
              hyperarcs are undirected), it does not have a head/tail or to/from distinction
              and it does not have a length. In a sense it has more in common with the node
              than the arc - as such it was decided not to override the arc class.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.hyperarc._nodes">
            <summary />
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.ConnectTo(GraphSynth.Representation.node)">
            <summary>
            Connects the hyperarc to a new node.
            </summary>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.DisconnectFrom(GraphSynth.Representation.node)">
            <summary>
            Disconnects the hyperarc from a node.
            </summary>
            <param name="removeNode">The remove node.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.#ctor(System.String,System.Collections.Generic.IEnumerable{GraphSynth.Representation.node})">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.hyperarc"/> class.
            </summary>
            <param name="newName">The new name.</param>
            <param name="attachedNodes">The attached nodes.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.hyperarc"/> class.
            </summary>
            <param name="newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.hyperarc"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.copy">
            <summary>
              Copies this instance of an arc and returns the copy.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.copy(GraphSynth.Representation.hyperarc)">
            <summary>
              Copies this.arc into the argument copyOfArc.
            </summary>
            <param name = "copyOfArc">The copy of arc.</param>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.nodes">
            <summary>
              Gets the list of attaced nodes.
            </summary>
            <value>The nodes.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.XmlNodes">
            <summary>
              Gets or sets the name of the node that the arc is coming from.
              It is necessary to do this, otherwise the serializer would rewrite 
              the actual node to the file (*.gxml file).
            </summary>
            <value>The XML from.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.degree">
            <summary>
              Gets the degree of the hyperarcs - the number of nodes that it connects to.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.IntraArcs">
            <summary>
            Gets the arcs that connect to and from nodes within this hyperarc.
            </summary>
            <value>The intra-connected arcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.hyperarcType">
            <summary>
              Gets or sets the type of the hyperarc.
            </summary>
            <value>The type of the hyperarc.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.XmlHyperarcType">
            <summary>
              Gets or sets the string describing the hyperarc type.
            </summary>
            <value>The type of the XML hyperarc.</value>
        </member>
        <member name="T:GraphSynth.Representation.node">
            <summary>
              One of the two basic classes for a graph is the node or vertex.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.node._arcs">
            <summary />
        </member>
        <member name="M:GraphSynth.Representation.node.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.node"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.node.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.node"/> class.
            </summary>
            <param name="newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.node.copy">
            <summary>
              Copies this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.node.copy(GraphSynth.Representation.node)">
            <summary>
              Copies the specified copy of node.
            </summary>
            <param name = "copyOfNode">The copy of node.</param>
        </member>
        <member name="P:GraphSynth.Representation.node.arcs">
            <summary>
              Gets the arcs connected to the node. This includes both arcs and hyperArcs.
            </summary>
            <value>The arcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.arcsTo">
            <summary>
              Gets the arcs entering this node - head (or to) of the
              arc is connected to this node.
            </summary>
            <value>The arcs to.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.arcsFrom">
            <summary>
              Gets the arcs leaving this node - tail (or from) of the
              arc is connected to this node.
            </summary>
            <value>The arcs from.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.X">
            <summary>
              Gets or sets the X coordinate.
            </summary>
            <value>The X coordinate.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.Y">
            <summary>
              Gets or sets the Y coordinate.
            </summary>
            <value>The Y coordinate.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.Z">
            <summary>
              Gets or sets the Z coordinate.
            </summary>
            <value>The Z coordinate.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.degree">
            <summary>
              Gets the degree. The degree or valence of a node is the number of arcs connecting to it.
              Currently this is used in recognition of a rule when the strictDegreeMatch is checked.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.nodeType">
            <summary>
              Gets or sets the type of the node.
            </summary>
            <value>The type of the node.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.XmlNodeType">
            <summary>
              Gets or sets the string stored in the XML code that describes the type.
            </summary>
            <value>The type of the XML node.</value>
        </member>
        <member name="T:GraphSynth.Representation.vertex">
            <summary>
              Originally, I created a separate edge and vertex class to allow for the future expansion
              of GraphSynth into shape grammars. I now have decided that the division is not useful, 
              since it simply deprived nodes of X,Y,Z positions. Many consider edge and arc, and vertex
              and node to be synonymous anyway but I prefer to think of edges and vertices as arcs and 
              nodes with spatial information. At any rate there is no need to have these inherited 
              classes, but I keep them for backwards-compatible purposes.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.vertex.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.vertex"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:GraphSynth.Representation.vertex.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.vertex"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.vertex.copy">
            <summary>
              Copies this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.IntCollectionConverter">
            <summary>
              A converter class for changing a collection of ints into a string and vice-versa.
            </summary>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
              Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name = "context">An <see cref = "T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
            <param name = "sourceType">A <see cref = "T:System.Type" /> that represents the type you want to convert from.</param>
            <returns>
              true if this converter can perform the conversion; otherwise, false.
            </returns>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
              Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name = "context">An <see cref = "T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
            <param name = "culture">The <see cref = "T:System.Globalization.CultureInfo" /> to use as the current culture.</param>
            <param name = "value">The <see cref = "T:System.Object" /> to convert.</param>
            <returns>
              An <see cref = "T:System.Object" /> that represents the converted value.
            </returns>
            <exception cref = "T:System.NotSupportedException">The conversion cannot be performed. </exception>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
              Determines whether this instance [can convert to] the specified context.
            </summary>
            <param name = "context">The context.</param>
            <param name = "sourceType">Type of the source.</param>
            <returns>
              <c>true</c> if this instance [can convert to] the specified context; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
              Converts to.
            </summary>
            <param name = "context">The context.</param>
            <param name = "culture">The culture.</param>
            <param name = "value">The value.</param>
            <param name = "s">The s.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.convert(System.String)">
            <summary>
              Converts the for a string of comma-separated-values to a List of ints.
            </summary>
            <param name = "value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.convert(System.Collections.Generic.List{System.Int32})">
            <summary>
              Converts the specified values from a List of ints to a comma-separated string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.convert(System.Int32[])">
            <summary>
              Converts the specified values from an array of ints to a comma-separated string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.DoubleCollectionConverter">
            <summary>
              A converter class for changing a collection of doubles into a string and vice-versa.
            </summary>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
              Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name = "context">An <see cref = "T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
            <param name = "sourceType">A <see cref = "T:System.Type" /> that represents the type you want to convert from.</param>
            <returns>
              true if this converter can perform the conversion; otherwise, false.
            </returns>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
              Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name = "context">An <see cref = "T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
            <param name = "culture">The <see cref = "T:System.Globalization.CultureInfo" /> to use as the current culture.</param>
            <param name = "value">The <see cref = "T:System.Object" /> to convert.</param>
            <returns>
              An <see cref = "T:System.Object" /> that represents the converted value.
            </returns>
            <exception cref = "T:System.NotSupportedException">The conversion cannot be performed. </exception>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
              Determines whether this instance [can convert to] the specified context.
            </summary>
            <param name = "context">The context.</param>
            <param name = "sourceType">Type of the source.</param>
            <returns>
              <c>true</c> if this instance [can convert to] the specified context; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
              Converts to.
            </summary>
            <param name = "context">The context.</param>
            <param name = "culture">The culture.</param>
            <param name = "value">The value.</param>
            <param name = "s">The s.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.convert(System.String)">
            <summary>
              Converts the for a string of comma-separated-values to a List of doubles.
            </summary>
            <param name = "value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.convert(System.Collections.Generic.List{System.Double})">
            <summary>
              Converts the specified values from a List of doubles to a comma-separated string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.convert(System.Double[])">
            <summary>
              Converts the specified values from an array of doubles to a comma-separated string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.StringCollectionConverter">
            <summary>
              Used to convert a single string into a list of strings and vice-versa.
            </summary>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
              Returns whether this converter can convert an object of the given type to the type of this converter, using the specified context.
            </summary>
            <param name = "context">An <see cref = "T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
            <param name = "sourceType">A <see cref = "T:System.Type" /> that represents the type you want to convert from.</param>
            <returns>
              true if this converter can perform the conversion; otherwise, false.
            </returns>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
              Converts the given object to the type of this converter, using the specified context and culture information.
            </summary>
            <param name = "context">An <see cref = "T:System.ComponentModel.ITypeDescriptorContext" /> that provides a format context.</param>
            <param name = "culture">The <see cref = "T:System.Globalization.CultureInfo" /> to use as the current culture.</param>
            <param name = "value">The <see cref = "T:System.Object" /> to convert.</param>
            <returns>
              An <see cref = "T:System.Object" /> that represents the converted value.
            </returns>
            <exception cref = "T:System.NotSupportedException">The conversion cannot be performed. </exception>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
              Determines whether this instance [can convert to] the specified context.
            </summary>
            <param name = "context">The context.</param>
            <param name = "sourceType">Type of the source.</param>
            <returns>
              <c>true</c> if this instance [can convert to] the specified context; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
              Converts to.
            </summary>
            <param name = "context">The context.</param>
            <param name = "culture">The culture.</param>
            <param name = "value">The value.</param>
            <param name = "s">The s.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.convert(System.String)">
            <summary>
              Converts the comma-separated-values into a List of strings.
            </summary>
            <param name = "value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.convert(System.Collections.Generic.List{System.String})">
            <summary>
              Converts the specified List of strings into a comma separated single string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.ErrorLogger">
            <summary>
              A class that allows us to dump errors to a txt file in the executable directory.
            </summary>
        </member>
        <member name="F:GraphSynth.ErrorLogger.ErrorLogFile">
            <summary>
              The contents of the Error log
            </summary>
        </member>
        <member name="M:GraphSynth.ErrorLogger.Catch(System.Exception)">
            <summary>
              Catches the specified exception.
            </summary>
            <param name = "Exc">The exc.</param>
        </member>
        <member name="M:GraphSynth.ErrorLogger.MakeErrorString(System.Exception,System.Boolean)">
            <summary>
              Makes the error string.
            </summary>
            <param name = "Exc">The exc.</param>
            <param name = "includeComputerData">if set to <c>true</c> [include computer data].</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.GlobalSettings">
            <summary>
            The Global Settings class loads the the .gsconfig file into an object which 
            is accessed throughout the system.
            </summary>
        </member>
        <member name="M:GraphSynth.GlobalSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.GlobalSettings"/> class.
            </summary>
        </member>
        <member name="F:GraphSynth.GlobalSettings.defaultRSFileNames">
            <summary>
            the default ruleset filenames relative to the rules directory
            </summary>
        </member>
        <member name="M:GraphSynth.GlobalSettings.readInSettings(System.String)">
            <summary>
            Reads in the settings.
            </summary>
            <param name="configPath">The file path.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.GlobalSettings.saveNewSettings(System.String)">
            <summary>
            Saves the new settings.
            </summary>
            <param name="filename">The filename.</param>
        </member>
        <member name="M:GraphSynth.GlobalSettings.LoadDefaultSeedAndRuleSets">
            <summary>
            Loads the default seed and rule sets.
            </summary>
        </member>
        <member name="M:GraphSynth.GlobalSettings.Duplicate">
            <summary>
            Copies the exisiting and returns it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.GlobalSettings.LoadDefaults">
            <summary>
            Loads the defaults.
            </summary>
        </member>
        <member name="M:GraphSynth.GlobalSettings.AttemptSubDirMigration(System.String)">
            <summary>
            Attempts to migrate all sub-directories when the working directory is changed.
            Currently this only occurs in the GUI when a working directory has been changed.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.ExecDir">
            <summary>
              The directory that GraphSynth.exe is located in
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.ConfigDir">
            <summary>
            Gets or sets the directory where the configuration file was found.
            </summary>
            <value>The config dir.</value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.FilePath">
            <summary>
              Gets or sets the location of the settings file.
            </summary>
            <value>The location.</value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.filer">
            <summary>
            Gets or sets the filer instance that controls the opening and saving of files.
            </summary>
            <value>
            The filer.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.seed">
            <summary>
            Gets or sets the seed graph - although this dll doesn't know what
            a graph is, so you need to "cast up" to really use it.
            </summary>
            <value>
            The seed.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.rulesets">
            <summary>
            Gets or sets the rulesets - although this dll doesn't know what
            a graph is, so you need to "cast up" to really use it.
            </summary>
            <value>
            The rulesets.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.numOfRuleSets">
            <summary>
            Gets or sets the number of rule sets.
            </summary>
            <value>
            The number of rule sets.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.MaxRulesToDisplay">
            <summary>
            Gets or sets the maximum rules to display in GUI driven User Choose.
            </summary>
            <value>
            The max rules to display.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.MaxRulesToApply">
            <summary>
            Gets or sets the max rules to apply.
            </summary>
            <value>
            The max rules to apply.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.WorkingDirAbsolute">
            <summary>
            Gets or sets the absolute working directory.
            </summary>
            <value>
            The absolute working directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.WorkingDirRelative">
            <summary>
            Gets or sets the relative working directory.
            </summary>
            <value>
            The relative working directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.InputDir">
            <summary>
            Gets or sets the input directory.
            </summary>
            <value>
            The input dir.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.InputDirAbs">
            <summary>
            Gets the absolute (rooted) input directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.OutputDir">
            <summary>
            Gets or sets the output directory.
            </summary>
            <value>
            The output dir.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.OutputDirAbs">
            <summary>
            Gets the absolute (rooted) output directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.RulesDir">
            <summary>
            Gets or sets the rules directory.
            </summary>
            <value>
            The rules directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.RulesDirAbs">
            <summary>
            Gets the absolute (rooted) rules directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.LocalHelpDir">
            <summary>
            Gets or sets the local help dir.
            </summary>
            <value>
            The local help dir.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.OnlineHelpURL">
            <summary>
            Gets or sets the online help URL.
            </summary>
            <value>
            The online help URL.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.GraphLayoutDir">
            <summary>
            Gets or sets the graph layout directory.
            </summary>
            <value>
            The graph layout directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.GraphLayoutDirAbs">
            <summary>
            Gets the absolute (rooted) graph layout directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.SearchDir">
            <summary>
            Gets or sets the search directory.
            </summary>
            <value>
            The search directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.SearchDirAbs">
            <summary>
            Gets the absolute (rooted) search directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.ErrorLogFile">
            <summary>
            Gets or sets the error log file.
            </summary>
            <value>
            The error log file.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.DefaultSeedFileName">
            <summary>
            Gets or sets the default name of the seed file.
            </summary>
            <value>
            The default name of the seed file.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.DefaultRuleSets">
            <summary>
            Gets or sets the default rule sets filename as a single string.
            </summary>
            <value>
            The default rule sets.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.CustomShapesFile">
            <summary>
            Gets or sets the custom shapes file.
            </summary>
            <value>
            The custom shapes file.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.CompiledRuleFunctions">
            <summary>
            Gets or sets the compiled param rules.
            </summary>
            <value>
            The compiledparam rules.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.SearchControllerPlayOnStart">
            <summary>
            Gets or sets a value indicating whether search controllers should automatically start playing
            when they are initiated.
            </summary>
            <value>
            	<c>true</c> if [search controller is set to auto-play]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.GetHelpFromOnline">
            <summary>
            Gets or sets a value indicating whether [get help from online].
            </summary>
            <value>
              <c>true</c> if [get help from online]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.RecompileRuleConditions">
            <summary>
            Gets or sets a value indicating whether [recompile rule conditions].
            </summary>
            <value>
            	<c>true</c> if [recompile rule conditions]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.DefaultVerbosity">
            <summary>
            Gets or sets the default verbosity.
            </summary>
            <value>
            The default verbosity.
            </value>
        </member>
        <member name="T:GraphSynth.IMainWindow">
            <summary>
            Interface for the main window of GraphSynth.
            </summary>
        </member>
        <member name="M:GraphSynth.IMainWindow.SetSelectedAddItem(System.Int32)">
            <summary>
            Sets the selected add item.
            </summary>
            <param name="i">The i.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.IMainWindow.FocusOnLabelEntry(System.Object)">
            <summary>
            Focuses on the label field for easy entry.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.propertyUpdate(System.Object)">
            <summary>
            Properties the update.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.SetCanvasPropertyScaleFactor(System.Double,System.Nullable{System.Boolean})">
            <summary>
            Sets the canvas property scale factor. This is needed since the
            GraphGUI needs to inform the main window what its scale is. The
            reason it is defined here, is because GraphGUI is defined in the
            CustomControls.dll and MainWindow is in the main EXE. Thus, we
            can make a call up from a dependent library to the main EXE.
            </summary>
            <param name="scale">The scale.</param>
            <param name="zoomToFit">The zoom to fit.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.addAndShowGraphWindow(System.Object,System.String)">
            <summary>
            Adds and shows a graph window.
            </summary>
            <param name="obj">The obj.</param>
            <param name="title">The title.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.addAndShowRuleWindow(System.Object,System.String)">
            <summary>
            Adds and shows a rule window.
            </summary>
            <param name="obj">The obj.</param>
            <param name="title">The title.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.addAndShowRuleSetWindow(System.Object,System.String)">
            <summary>
            Adds and shows a rule window.
            </summary>
            <param name="obj">The obj.</param>
            <param name="title">The title.</param>
        </member>
        <member name="P:GraphSynth.IMainWindow.SelectedAddItem">
            <summary>
            Gets the selected add item.
            </summary>
            <value>The selected add item.</value>
        </member>
        <member name="P:GraphSynth.IMainWindow.stayOn">
            <summary>
            Gets a value indicating whether the selected item should [stay on].
            </summary>
            <value><c>true</c> if [stay on]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.IMainWindow.Dispatcher">
            <summary>
            Gets the dispatcher.
            </summary>
            <value>The dispatcher.</value>
        </member>
        <member name="P:GraphSynth.IMainWindow.shortCutKeys">
            <summary>
            Gets the short cut keys.
            </summary>
            <value>The short cut keys.</value>
        </member>
        <member name="T:GraphSynth.SearchIOToTextWriter">
            <summary>
              this class simply helps SearchIO get its output to the sidebar in GraphSynth.
              It does this by inheriting from the TextWriter class. Borrowed from ? on CodeProject.
            </summary>
        </member>
        <member name="F:GraphSynth.SearchIOToTextWriter.outputBox">
            <summary>
              The output box where text is presented to the user.
            </summary>
        </member>
        <member name="M:GraphSynth.SearchIOToTextWriter.WriteLine(System.String)">
            <summary>
              Writes the line.
            </summary>
            <param name = "str">The STR.</param>
        </member>
        <member name="P:GraphSynth.SearchIOToTextWriter.Encoding">
            <summary>
              When overridden in a derived class, returns the <see cref = "T:System.Text.Encoding" /> in which the output is written.
            </summary>
            <value></value>
            <returns>The Encoding in which the output is written.</returns>
        </member>
        <member name="T:GraphSynth.Representation.embeddingRule">
            <summary>
              The embedding rule defines what to do with arcs that are freed (one or both of its connecting
              nodes is deleted) by the enclosing grammar rule.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.freeArcLabels">
            <summary>
              The list of labels that the free arc must have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.freeArcNegabels">
            <summary>
              The list of labels that the free arc must NOT have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.neighborNodeLabels">
            <summary>
              The list of labels that the remaining neighboring node 
              must have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.neighborNodeNegabels">
            <summary>
              The list of labels that the remaining neighboring node 
              must NOT have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.oldLabels">
            <summary>
              In order to be backwards compatible, this field captures the old fields and converts them
              to proper places. See use in BasicFiler.cs
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.embeddingRule.arcIsFree(GraphSynth.Representation.arc,GraphSynth.Representation.designGraph,System.SByte@,GraphSynth.Representation.node@)">
            <summary>
              Is the arc a free arc from this grammar rule?
            </summary>
            <param name = "a">A.</param>
            <param name = "host">The host.</param>
            <param name = "freeEndIdentifier">The free end identifier.</param>
            <param name = "neighborNode">The neighbor node.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.embeddingRule.ruleIsRecognized(System.SByte,GraphSynth.Representation.arc,GraphSynth.Representation.node,GraphSynth.Representation.node)">
            <summary>
              Is the rule recognized on the given inputs?
            </summary>
            <param name = "freeEndIdentifier">The free end identifier.</param>
            <param name = "freeArc">The free arc.</param>
            <param name = "neighborNode">The neighbor node.</param>
            <param name = "nodeRemoved">The node removed.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.LNodeName">
            <summary>
              Gets or sets the name of the L node that was attached to the 
              free arc. This is NOT the name of the node in the host graph, 
              but in the L of the rule.
            </summary>
            <value>The name of the L node.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.RNodeName">
            <summary>
              Gets or sets the name of the R node to connect this arc to. There is no need to include 
              any other defining character - of course we still need to find the corresponding node 
              in H1 to connect it to. Note, this is also the main quality that distinguishes the 
              approach as NCE or NLC, as the control is given to the each individual of R-L (or the
              daughter graph in the NCE lingo) as opposed to simply a label based method.
            </summary>
            <value>The name of the R node.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.originalDirection">
            <summary>
              Gets or sets the original direction that must be free for this embedding rule to be recognized.
              in order to give the edNCE approach the "ed" quality, we must allow for the possibility of
              recognizing arcs having a particular direction. The original direction can be either +1 meaning
              "to", or -1 meaning "from", or 0 meaning no imposed direction - this indicates what side of the 
              arc is dangling. Furthermore, the newDirection, can specify a new direction of the arc ("to",
              or "from" being the new connection) or "" (unspecified) for updating the arc. This allows us 
              to change the direction of the arc, or keep it as is.
            </summary>
            <value>The original direction.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.newDirection">
            <summary>
              Gets or sets the new direction of the arc. Yes, the arc can actually be flipped by the embedding rule.
            </summary>
            <value>The new direction.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.allowArcDuplication">
            <summary>
              Gets or sets a value indicating whether [allow arc duplication].
            </summary>
            <value><c>true</c> if [allow arc duplication]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:GraphSynth.Representation.grammarRule">
            <summary>
            </summary>
            <summary>
            A partial description of the grammar rule class. In addition to storing designGraphs
            for both the left and right hand sides, there are a variety of functions for describing
            how a rule recognizes on a host, and how it makes changes via apply.
            </summary>
            <summary>
            A partial description of the grammar rule class. In addition to storing designGraphs
            for both the left and right hand sides, there are a variety of functions for describing
            how a rule recognizes on a host, and how it makes changes via apply.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.DLLofFunctions">
            <summary>
              any mathematical operations are fair game for the recognize and apply local variables.
              At the end of a graph recognition, we check all the recognize functions, if any yield a 
              positive number than the rule is infeasible. This is done in case1LocationFound.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.applyFuncs">
            <summary>
              a list of MethodInfo's corresponding to the strings in applyFunctions
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.globalLabelStartLocs">
            <summary>
              These are place holders when the user has clicked OrderedGlobalLabels. There may, in fact,
              be multiple locations for the globalLabels to be recognized. The are determined in the 
              OrderLabelsMatch function.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.options">
            <summary>
              this is where we store the subgraphs or locations of where the
              rule can be applied. It's global to a particular L but it is invoked
              only at the very bottom of the recursion tree - see the end of
              recognizeRecursion().
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.recognizeFuncs">
            <summary>
              a list of MethodInfo's corresponding to the strings in recognizeFunctions
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.otherArcsInHost(GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph)">
            <summary>
            This function is used when checking for an induced subgraph (near line 300 of this file under
            the function case1LocationFound). I have placed it here near the induced property because that's
            a logical place as any in such a big file.
            </summary>
            <param name="host">The host graph.</param>
            <param name="location">The location.</param>
            <returns>
            true - if no other arcs exist between the locatedNodes.
            </returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.labelsMatch(System.Collections.Generic.ICollection{System.String})">
            <summary>
              Similar to label matching functions in ruleNode and ruleArc, this function is used at the
              beginning of the recognition process to check the global labels of the rule with the host.
              I have placed it here near the containsAllGlobalLabels property because that's
              a logical place as any in such a big file.
            </summary>
            <param name = "hostLabels">The host labels.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.makeUniqueNodeName(System.String)">
            <summary>
              Makes a unique name of a node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.makeUniqueArcName(System.String)">
            <summary>
              Makes a unique name of an arc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.makeUniqueHyperarcName(System.String)">
            <summary>
              Makes a unique name of a hyperarc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.recognize(GraphSynth.Representation.designGraph,System.Boolean,GraphSynth.Representation.designGraph)">
            <summary>
            Determines locations where the rule is recognized on the specified host.
            here is the big one! Although it looks fairly short, a lot of time can be spent in
            the recursion that it invokes. Before we get to that, we want to make sure that
            our time there is well spent. As a result, we try to rule out whether the rule
            can even be applied at first -- hence the series of if-thens. If you don't
            meet the first, leave now! likewise for the second. The third is a little trickier.
            if there are no nodes or arcs in this rule, then it has already proven to be valid
            by the global labels - thus return a single location.
            The real work happens in the findNewStartElement which is time-consuming so we first
            do some simply counting to see if the host is bigger than the LHS.
            When findNewStartElement recurses down and divides, a number of options may be created
            in the final method (LocationFound). If there are multiple locations within the
            global labels then we merge the two together.
            </summary>
            <param name="host">The host.</param>
            <param name="InParallel">if set to <c>true</c> [in parallel].</param>
            <param name="location">The location, which is what the function finds anyway. So, 
            this is only for doing a test to for a section of a graph where some elements are already known.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.HyperArcPreclusionCheckForSingleNode(GraphSynth.Representation.node,GraphSynth.Representation.node,GraphSynth.Representation.designGraph)">
            <summary>
            Hyperarc preclusion check for single node.
            </summary>
            <param name="LNode">The L node.</param>
            <param name="hostNode">The host node.</param>
            <param name="location">The location.</param>
            <returns>true if preclusions are correct for this node (it is not included
            in hyperarcs it was intentionally precluded from.</returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.HyperArcPreclusionCheckForAllNodes(GraphSynth.Representation.designGraph)">
            <summary>
            Hyperarc preclusion check for all nodes.
            </summary>
            <param name="location">The location.</param>
            <returns>true if preclusions are correct in host.</returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.findLMappedElement(GraphSynth.Representation.designGraph,System.String)">
            <summary>
            Given the name of an element in the rule, this functions finds the corresponding element
            in the host.
            </summary>
            <param name="LMapping">the L-mapping for the recognized location of the rule</param>
            <param name="GraphElementName">the name of an element in the rule</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.findRMappedElement(GraphSynth.Representation.designGraph,System.String)">
            <summary>
            Given the name of an element in the rule, this functions finds the corresponding element
            in the host.
            </summary>
            <param name="RMapping">the R-mapping for the recognized location of the rule</param>
            <param name="GraphElementName">the name of an element in the rule</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.apply(GraphSynth.Representation.designGraph,GraphSynth.Representation.option,System.Double[])">
            <summary>
              Applies the rule to the specified host.
            </summary>
            <param name = "host">The host.</param>
            <param name = "Lmapping">The lmapping.</param>
            <param name = "parameters">The parameters.</param>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.updateAdditionalFunctions(GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph,System.Collections.IEnumerable)">
            <summary>
              The final update step is to invoke additional functions for the rule. 
              These are traditionally called the Parametric Application Functions, but
              they can do any custom modifications to the host.
            </summary>
            <param name = "Lmapping">The lmapping.</param>
            <param name = "host">The host.</param>
            <param name = "Rmapping">The rmapping.</param>
            <param name = "parameters">The parameters.</param>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule._regularizationMatrix">
            <summary>
              this matrix determines the transform to place the first node at (0,0) and the 
              second node at (r,0). This is not stored in the file since it can be quickly 
              determined.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.ResetRegularizationMatrix">
            <summary>
              Resets the regularization matrix.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.calculateRegularizationMatrix">
            <summary>
              Calculates the regularization matrix.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.ReorderNodes">
            <summary>
            Reorders the nodes for best shape transform. This is to put all NOT-exist nodes
            at the end of the list and to avoid unlikely problems when first 3 or 4 nodes 
            are collinear or sitting on top of each other.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.TransformPositionOfNode(GraphSynth.Representation.node,System.Double[0:,0:],GraphSynth.Representation.node)">
            <summary>
              Updates the position of a node.
            </summary>
            <param name = "update">The node to update.</param>
            <param name = "T">The Transformation matrix, T.</param>
            <param name = "given">The given rule node.</param>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.TransfromShapeOfNode(GraphSynth.Representation.node,System.Double[0:,0:])">
            <summary>
            Transfroms the shape of node.
            </summary>
            <param name="update">The update.</param>
            <param name="T">The T.</param>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.name">
            <summary>
              Gets or sets the name of the rule.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.comment">
            <summary>
              Gets or sets a comment about the rule.
            </summary>
            <value>The comment.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.termination">
            <summary>
              Gets or sets a value indicating whether this <see cref="T:GraphSynth.Representation.grammarRule"/> is termination.
            </summary>
            <value><c>true</c> if termination; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.embeddingRules">
            <summary>
              Gets or sets the embedding rules.
            </summary>
            <value>The embedding rules.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.recognizeFunctions">
            <summary>
              Gets or sets the additional recognize functions names.
            </summary>
            <value>The recognize functions.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.applyFunctions">
            <summary>
              Gets or sets the apply functions.
            </summary>
            <value>The apply functions.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.L">
            <summary>
              Gets or sets  the left-hand-side of the rule. It is a graph that is to be 
              recognized in the host graph.
            </summary>
            <value>The L.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.R">
            <summary>
              Gets or sets the right-hand-side of the rule. It is a graph that is to be 
              inserted (glued) into the host graph.
            </summary>
            <value>The R.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.spanning">
            <summary>
              Gets or sets a value indicating whether this <see cref="T:GraphSynth.Representation.grammarRule"/> is spanning.
            </summary>
            <value><c>true</c> if spanning; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.induced">
            <summary>
              Gets or sets a value indicating whether this <see cref="T:GraphSynth.Representation.grammarRule"/> is induced.
            </summary>
            <value><c>true</c> if induced; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.negateLabels">
            <summary>
              Gets or sets the negating labels - labels that must NOT exist in the host.
            </summary>
            <value>The negating labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.containsAllGlobalLabels">
            <summary>
              Gets or sets a value indicating whether the host must contains only the
              global labels of the rule. Said another way, the rule must contain all global labels
              in the host to be a valid match. If false, then a subset of global labels is sufficient.
            </summary>
            <value>
              <c>true</c> if [contains all global labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.OrderedGlobalLabels">
            <summary>
              Gets or sets a value indicating whether the host must contain the
              global labels in the presented order. This is mainly to allow for the creation of traditional
              string grammars.
            </summary>
            <value><c>true</c> if [ordered global labels]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.UseShapeRestrictions">
            <summary>
              Gets or sets a value indicating whether [use shape restrictions].
            </summary>
            <value>
              <c>true</c> if [use shape restrictions]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.RestrictToNodeShapeMatch">
            <summary>
            Gets or sets a value indicating whether [restrict to node shape match].
            </summary>
            <value>
            	<c>true</c> if [restrict to node shape match]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.TransformNodePositions">
            <summary>
            Gets or sets a value indicating whether [transform node positions].
            </summary>
            <value><c>true</c> if [transform node positions]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.TransformNodeShapes">
            <summary>
            Gets or sets a value indicating whether the node shapes are also transformed or simply their position.
            </summary>
            <value><c>true</c> if [transform node shapes]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Translate">
            <summary>
              Gets or sets the translate transformation allowance.
            </summary>
            <value>The translate.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Scale">
            <summary>
              Gets or sets the scale transformation allowance.
            </summary>
            <value>The scale.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Skew">
            <summary>
              Gets or sets the skew transformation allowance.
            </summary>
            <value>The skew.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Flip">
            <summary>
              Gets or sets the flip transformation allowance.
            </summary>
            <value>The flip.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Rotate">
            <summary>
              Gets or sets a value indicating whether this <see cref="T:GraphSynth.Representation.grammarRule"/> allows a rotation transformation.
            </summary>
            <value><c>true</c> if rotate; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Projection">
            <summary>
              Gets or sets the projection transformation allowance.
            </summary>
            <value>The projection.</value>
        </member>
        <member name="T:GraphSynth.Representation.option">
            <summary>
              A rule is not enough - the Opion class captures all the details of
              an decision option from one point in the search process. The list of
              options are presented in the choice for which rule to apply. Option 
              contains references to the location where the rule is applicable, 
              the rule itself, along with its number in the ruleSet and the ruleSet's
              number when there are multiple ruleSets.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.option.parameters">
            <summary>
              A list of parameters chosen and used by the apply fuctions of the rule.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.option.apply(GraphSynth.Representation.designGraph,System.Double[])">
            <summary>
              Applies the option to the specified host. It is essentially
              a shorthand instead of calling 
              option.rule.apply(option.location, host, parameters); we call
              option.apply(host, parameters).
            </summary>
            <param name = "host">The host.</param>
            <param name = "Parameters">The parameters.</param>
        </member>
        <member name="M:GraphSynth.Representation.option.copy">
            <summary>
              Returns a copy of this instance of option. Note that location is a 
              shallow copy and applies to the same host.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.option.optionNumber">
            <summary>
              Gets or sets the option number.
            </summary>
            <value>The option number.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.ruleSetIndex">
            <summary>
              Gets or sets the index of the rule set.
            </summary>
            <value>The index of the rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.ruleNumber">
            <summary>
              Gets or sets the rule number.
            </summary>
            <value>The rule number.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.rule">
            <summary>
              Gets or sets the rule.
            </summary>
            <value>The rule.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.location">
            <summary>
              Gets or sets the location of the option within the host.
              The location is a designgraph that includes the very same
              elements of the host (arcs, hyperarcs, and nodes) but in the
              order that corresponds to the elements in the L of the rule.
            </summary>
            <value>The location.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.globalLabelStartLoc">
            <summary>
              Gets or sets the global label start loc.
            </summary>
            <value>The global label start loc.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.positionTransform">
            <summary>
              Gets or sets the position transform.
            </summary>
            <value>The position transform.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.confluence">
            <summary>
              Gets or sets the confluence.
            </summary>
            <value>The confluence.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.probability">
            <summary>
              Gets or sets the probability.
            </summary>
            <value>The probability.</value>
        </member>
        <member name="T:GraphSynth.Representation.ruleArc">
            <summary>
              The ruleArc class is an inherited class from arc which includes additional details
              necessary to correctly perform recognition. This mostly hinges on the "subset or equal"
              Booleans.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleArc"/> class with a particular name.
            </summary>
            <param name="newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleArc"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.copy(GraphSynth.Representation.arc)">
            <summary>
              Copies this instance into the (already intialized) copyOfArc.
            </summary>
            <param name = "copyOfArc">A new copy of arc.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.matchWith(GraphSynth.Representation.arc,System.Boolean,System.Boolean)">
            <summary>
              Returns a true/false based on if the host arc matches with this ruleArc. 
            </summary>
            <param name = "hostArc">The host arc.</param>
            <param name = "hostTraversesForward">if set to <c>true</c> [traverse forward].</param>
            <param name = "LTraversesForward">if set to <c>true</c> [traverse forward].</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.ConvertFromArc(GraphSynth.Representation.arc)">
            <summary>
              Converts an arc to a ruleArc and returns it with default Booleans.
              The original arc is unaffected.
            </summary>
            <param name = "a">an arc A.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.containsAllLocalLabels">
            <summary>
              Gets or sets a value indicating whether arc must contain all the local labels of the matching element.
            </summary>
            <value>
              <c>true</c> if [contains all local labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.directionIsEqual">
            <summary>
              Gets or sets a value indicating whether the directionality within the arc is to match
              perfectly. If false then all (singly)-directed arcs
              will match with doubly-directed arcs, and all undirected arcs will match with all
              directed and doubly-directed arcs. Of course, a directed arc going one way will 
              still not match with a directed arc going the other way.
              If true, then undirected only matches with undirected, directed only with directed (again, the
              actual direction must match too), and doubly-directed only with doubly-directed.
            </summary>
            <value><c>true</c> if [direction is equal]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.nullMeansNull">
            <summary>
              Gets or sets a value indicating whether dangling (the null reference to node) arc are only
              to match with dangling arcs.If this is set to false, then we are saying a 
              null reference on an arc can be matched with a null in the graph or any node in the graph. 
              Like the above, a false value is like a subset in that null is a subset of any actual node. 
              And a true value means it must match exactly or in otherwords, "null means null" - null 
              matches only with a null in the host. If you want the rule to be recognized only when an actual
              node is present simply add a dummy node with no distinguishing characteristics. That would
              in turn nullify this boolean since this boolean only applies when a null pointer exists in
              the rule.
            </summary>
            <value><c>true</c> if [null means null]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.negateLabels">
            <summary>
              Gets the negating labels. The labels that must not exist for correct recognition.
            </summary>
            <value>The negate labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.NotExist">
            <summary>
            Gets or sets a value indicating whether the rule-arc should not exist in the
            host graph.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:GraphSynth.Representation.ruleHyperarc">
            <summary>
              The ruleHyperArc class is an inherited class from hyperarc which includes additional details
              necessary to correctly perform recognition. This mostly hinges on the "subset or equal"
              Booleans.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleHyperarc"/> class.
            </summary>
            <param name="newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleHyperarc"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.copy(GraphSynth.Representation.hyperarc)">
            <summary>
              Copies this instance into the (already intialized) copyOfHyperArc.
            </summary>
            <param name = "copyOfHyperArc">The copy of node.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.matchWith(GraphSynth.Representation.hyperarc)">
            <summary>
              Returns a true/false based on if the host hyperarc matches with this ruleHyperarc.
              This calls the next two functions which check labels and type.
            </summary>
            <param name = "hostHyperArc">The host hyperarc.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.ConvertFromHyperArc(GraphSynth.Representation.hyperarc)">
            <summary>
              Converts a hyperarc to a ruleHyperArc and returns it with default Booleans.
              The original hyperarc is unaffected.
            </summary>
            <param name = "ha">The hyperarc, ha.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.containsAllLocalLabels">
            <summary>
              Gets or sets a value indicating whether [contains all local labels].
            </summary>
            <value>
              <c>true</c> if [contains all local labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.strictNodeCountMatch">
            <summary>
            Gets or sets a value indicating whether [strict node count match].
            </summary>
            <value>
            	<c>true</c> if [strict node count match]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.negateLabels">
            <summary>
              Gets the negate labels.
            </summary>
            <value>The negate labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.NotExist">
            <summary>
            Gets or sets a value indicating whether the rule-hyperarc should not exist in the
            host graph.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.degree">
            <summary>
            Gets the degree of the hyperarcs - the number of nodes that it connects to.
             A slight difference exists for ruleNode since we don't want to count "NotExist" arcs.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="T:GraphSynth.Representation.ruleNode">
            <summary>
              The ruleNode class is an inherited class from node which includes additional details
              necessary to correctly perform recognition. This mostly hinges on the "subset or equal"
              Booleans.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleNode"/> class with a particular name.
            </summary>
            <param name="newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleNode"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.copy(GraphSynth.Representation.node)">
            <summary>
              Copies this instance into the (already intialized) copyOfNode.
            </summary>
            <param name = "copyOfNode">A new copy of node.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.matchWith(GraphSynth.Representation.node)">
            <summary>
              Returns a true/false based on if the host node matches with this ruleNode.
              This calls the next two functions which check labels and type.
            </summary>
            <param name = "hostNode">The host node.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.ConvertFromNode(GraphSynth.Representation.node)">
            <summary>
              Converts a node to a ruleNode and returns it with default Booleans.
              The original node is unaffected.
            </summary>
            <param name = "n">a node, n.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.containsAllLocalLabels">
            <summary>
              Gets or sets a value indicating whether the host node must contain all the local labels of the matching element.
            </summary>
            <value>
              <c>true</c> if [contains all local labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.strictDegreeMatch">
            <summary>
              Gets or sets a value indicating whether [strict degree match] is required for recognition.
            </summary>
            <value><c>true</c> if [strict degree match]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.negateLabels">
            <summary>
              Gets the negating labels. The labels that must not exist for correct recognition.
            </summary>
            <value>The negate labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.NotExist">
            <summary>
            Gets or sets a value indicating whether the rule-node should not exist in the
            host graph.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.degree">
            <summary>
            Gets the degree. The degree or valence of a node is the number of arcs connecting to it.
            Currently this is used in recognition of a rule when the strictDegreeMatch is checked.
            A slight difference exists for ruleNode since we don't want to count "NotExist" arcs.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="T:GraphSynth.Representation.ruleSet">
            <summary>
              The ruleset class represents one of the three main file types of GraphSynth. A ruleset is saved as a .rsxml. It represents a
              language of rules that operate in concert. The included rules are all loaded at once, and used to populate a list of
              options which make changes to a host.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.ruleSet.nextGenerationStep">
            <summary>
              For a particular set of rules, we need to specify what generation should
              do if any of five conditions occur during the recognize->choose->apply
              cycle. The enumerator, nextGenerationSteps, listed in globalSettings.cs
              indicates what to do. The five correspond directly to the five elements
              of another enumerator called GenerationStatuses. These five possibilties are:
              Normal, Choice, CycleLimit, NoRules, TriggerRule. So, following normal operation 
              of RCA (normal), we perform the first operation stated below, nextGenerationStep[0]
              this will likely be to LOOP and contine apply rules. Defaults for these are
              specified in App.gsconfig.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.ruleSet.ruleFileNames">
            <summary>
              Represents a list of the rule file names.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.ruleSet.rules">
            <summary>
              Represents a list of the rules included within the ruleset.
              The rules are clearly part of the set, but these are not stored
              in the rsxml file, only the ruleFileNames.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.nextRuleSet(GraphSynth.GenerationStatuses)">
            <summary>
              Retrieves the index of the next rule set.A helper function to RecognizeChooseApplyCycle.
              This function returns what the new ruleSet will be. Here the enumerator nextGenerationSteps
              and GenerationStatuses is used to great affect. Understand that if a negative number is
              returned, the cycle will be stopped.
            </summary>
            <param name = "status">The status.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleSet"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleSet"/> class.
            </summary>
            <param name="defaultRulesDir">The default rules dir.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.recognize(GraphSynth.Representation.designGraph,System.Boolean)">
            <summary>
            This is the recognize function called within the RCA generation. It is
            fairly straightforward method that basically invokes the more complex
            recognize function for each rule within it, and returns a list of
            options.
            </summary>
            <param name="host">The host.</param>
            <param name="InParallel">if set to <c>true</c> [in parallel].</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.Add(GraphSynth.Representation.grammarRule)">
            <summary>
              Adds the specified new rule.
            </summary>
            <param name = "newRule">The new rule.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.Remove(GraphSynth.Representation.grammarRule)">
            <summary>
              Removes the specified remove rule.
            </summary>
            <param name = "removeRule">The remove rule.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.loadAndCompileSourceFiles(GraphSynth.Representation.ruleSet[],System.Boolean,System.String,System.String)">
            <summary>
              Loads and compiles the source files.
            </summary>
            <param name = "rulesets">The rulesets.</param>
            <param name = "recompileRules">if set to <c>true</c> [recompile rules].</param>
            <param name = "compiledparamRules">The compiledparam rules.</param>
            <param name = "execDir">The exec dir.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.FindSourceFiles(GraphSynth.Representation.ruleSet[],System.Collections.Generic.List{System.String},System.String)">
            <summary>
              Finds the source files.
            </summary>
            <param name = "rulesets">The rulesets.</param>
            <param name = "allSourceFiles">All source files.</param>
            <param name = "rulesDirectory">The rules directory.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.CompileSourceFiles(GraphSynth.Representation.ruleSet[],System.Collections.Generic.List{System.String},System.CodeDom.Compiler.CompilerResults@,System.String,System.String,System.String)">
            <summary>
              Compiles the source files.
            </summary>
            <param name = "rulesets">The rulesets.</param>
            <param name = "allSourceFiles">All source files.</param>
            <param name = "cr">The cr.</param>
            <param name = "rulesDir">The rules dir.</param>
            <param name = "execDir">The exec dir.</param>
            <param name = "compiledparamRules">The compiledparam rules.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.initializeFileWatcher(System.String)">
            <summary>
              Initializes the file watcher. There is no way to prevent watching all 
              the *.xml files in the rulesDirectory - it seems that filter is limited
              to this. That's okay, in each of the events that is triggered we first
              see if it is important to tell the user.
            </summary>
            <param name = "RulesDir">The rules dir.</param>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.name">
            <summary>
              Gets or sets the name for the ruleSet - usually set to the filename
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.TriggerRuleNum">
            <summary>
              Gets or sets the trigger rule num. Note: the rule numbers start at 1
              not zero. Here we keep track by using a zero-based private field with
              this property (as a way to remember. I know it sounds strange, but it
              works).
            </summary>
            <value>The trigger rule num.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.choiceMethod">
            <summary>
              Gets or sets the choice method - either automatic or by design.
            </summary>
            <value>The choice method.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.interimCandidates">
            <summary>
              Gets or sets the feasibility state of the interim candidates.
            </summary>
            <value>The interim candidates.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.finalCandidates">
            <summary>
              Gets or sets the feasibility state of the final candidates.
            </summary>
            <value>The final candidates.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.RuleSetIndex">
            <summary>
              Gets or sets the index of the rule set.
            </summary>
            <value>The index of the rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.recognizeSourceFiles">
            <summary>
              Gets or sets the recognize source file names (string paths).
            </summary>
            <value>The recognize source files.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.applySourceFiles">
            <summary>
              Gets or sets the apply source file names (string paths).
            </summary>
            <value>The apply source files.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.filer">
            <summary>
              Gets or sets the filer.
            </summary>
            <value>The filer.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.rulesDir">
            <summary>
              Gets or sets the rules dir.
            </summary>
            <value>The rules dir.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterNormal">
            <summary>
              Gets or sets the generation method after normal.
            </summary>
            <value>The generation after normal.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterChoice">
            <summary>
              Gets or sets the generation method after choice.
            </summary>
            <value>The generation after choice.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterCycleLimit">
            <summary>
              Gets or sets the generation method after cycle limit.
            </summary>
            <value>The generation after cycle limit.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterNoRules">
            <summary>
              Gets or sets the generation method after no rules.
            </summary>
            <value>The generation after no rules.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterTriggerRule">
            <summary>
              Gets or sets the generation method after trigger rule.
            </summary>
            <value>The generation after trigger rule.</value>
        </member>
        <member name="T:GraphSynth.SearchIO">
            <summary>
              The static class that handles input and output statements from a
              Search Process.
            </summary>
        </member>
        <member name="M:GraphSynth.SearchIO.getIteration(System.String)">
            <summary>
              Gets the iteration.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.getMiscObject(System.String)">
            <summary>
              Gets the misc object.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.GetTerminateRequest(System.String)">
            <summary>
            Gets the Boolean indicating whether a termination request has been sent.
            </summary>
            <param name="searchThreadName">Name of the search thread.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.setTerminationRequest(System.String)">
            <summary>
              Sets the termination request.
            </summary>
            <param name = "threadName">Name of the thread.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.setTimeInterval(System.String,System.TimeSpan)">
            <summary>
              Sets the time interval.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <param name = "value">The value.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.getTimeInterval(System.String)">
            <summary>
              Gets the time interval.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <returns></returns>
        </member>
        <member name="F:GraphSynth.SearchIO.defaultVerbosity">
            <summary>
              Defines the default verbosity of all search threads.
            </summary>
        </member>
        <member name="M:GraphSynth.SearchIO.setVerbosity(System.String,System.Int32)">
            <summary>
              Sets the verbosity.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <param name = "value">The value.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.getVerbosity(System.String)">
            <summary>
              Gets the verbosity.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.output(System.Object,System.Int32)">
            <summary>
             Calling SearchIO.output will output the string, message, to the 
             text display on the right of GraphSynth, but ONLY if the verbosity (see
             below) is greater than or equal to your specified limit for this message.
             the verbosity limit must be 0, 1, 2, 3, or 4.
            </summary>
            <param name="message">The message.</param>
            <param name="verbosityLimit">The verbosity limit.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.output(System.Object[])">
            <summary>
            Outputs the one item of the specified list corresponding to the particular verbosity.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.MessageBoxShow(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Shows a messagebox (pop-up or dialog) - redirects to System.Windows.MessageBox.Show().
            </summary>
            <param name="messageBoxText">The message box text.</param>
            <param name="caption">The caption.</param>
            <param name="iconStr">The icon STR.</param>
            <param name="buttonStr">The buttons to show.</param>
            <param name="defaultResultStr">The default result STR.</param>
            <param name="optionsStr">The options STR.</param>
            <returns></returns>
        </member>
        <member name="F:GraphSynth.SearchIO.main">
            <summary>
              A reference to the main window
            </summary>
        </member>
        <member name="M:GraphSynth.SearchIO.addAndShowGraphWindow(System.Object,System.String)">
            <summary>
              Adds and shows a graph window.
            </summary>
            <param name = "graphObjects">The graph objects.</param>
            <param name = "title">The title.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.addAndShowRuleWindow(System.Object,System.String)">
            <summary>
              Adds and shows a rule window.
            </summary>
            <param name = "ruleObjects">The rule objects.</param>
            <param name = "title">The title.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.addAndShowRuleSetWindow(System.Object,System.String)">
            <summary>
            Adds and shows a ruleset window.
            </summary>
            <param name="ruleSetObjects">The rule set objects.</param>
            <param name="title">The title.</param>
        </member>
        <member name="P:GraphSynth.SearchIO.processNum">
            <summary>
              Gets the process number.
            </summary>
            <value>The process number.</value>
        </member>
        <member name="P:GraphSynth.SearchIO.iteration">
            <summary>
              Gets or sets the iteration.
            </summary>
            <value>The iteration.</value>
        </member>
        <member name="P:GraphSynth.SearchIO.miscObject">
            <summary>
              Gets or sets the misc object.
            </summary>
            <value>The misc object.</value>
        </member>
        <member name="P:GraphSynth.SearchIO.terminateRequest">
            <summary>
              Gets a value indicating whether [terminate request].
            </summary>
            <value><c>true</c> if [terminate request]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.SearchIO.timeInterval">
            <summary>
              Gets the time interval.
            </summary>
            <value>The time interval.</value>
        </member>
        <member name="P:GraphSynth.SearchIO.verbosity">
            <summary>
              Gets the verbosity.
            </summary>
            <value>The verbosity.</value>
        </member>
        <member name="T:GraphSynth.choiceMethods">
            <summary>
            Defines whether the choice method of a particular ruleset is done
            by some design agent (human or computer) or is automatic - meaning 
            once a rule is found to be recognized on a host, it is invoked.
            </summary>
        </member>
        <member name="F:GraphSynth.choiceMethods.Design">
            <summary>
            A set of options are first defined by an exhaustive recognition
            of all rules in the ruleset. The decision of which option to 
            choose is left to some design agent.
            </summary>
        </member>
        <member name="F:GraphSynth.choiceMethods.Automatic">
            <summary>
            Whenever a rule is recognized it is invoked. Rules invoked in 
            the order presented in the ruleset.
            </summary>
        </member>
        <member name="T:GraphSynth.feasibilityState">
            <summary>
            Defines whether the candidates created by a particular ruleset 
            are feasible candidates and hence ready for evaluation, or
            developing candidates which are yet to completed.
            </summary>
        </member>
        <member name="F:GraphSynth.feasibilityState.Unspecified">
            <summary/>
        </member>
        <member name="F:GraphSynth.feasibilityState.Developing">
            <summary>
            Candidates are not yet complete, they are still 
            developing; not ready for evaluation.
            </summary>
        </member>
        <member name="F:GraphSynth.feasibilityState.Feasible">
            <summary>
            Candidates are feasible and ready for evaluation.
            </summary>
        </member>
        <member name="T:GraphSynth.nextGenerationSteps">
            <summary>
            Defines how the generation process is to continue.
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.Unspecified">
            <summary />
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.Stop">
            <summary>
            stop the generation process
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.Loop">
            <summary>
            loop within current ruleset
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToPrevious">
            <summary>
            go to the previous ruleset
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToNext">
            <summary>
            go to the next ruleset
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet0">
            <summary>
            go to ruleset #0
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet1">
            <summary>
            go to ruleset #1
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet2">
            <summary>
            go to ruleset #2
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet3">
            <summary>
            go to ruleset #3
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet4">
            <summary>
            go to ruleset #4
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet5">
            <summary>
            go to ruleset #5
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet6">
            <summary>
            go to ruleset #6
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet7">
            <summary>
            go to ruleset #7
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet8">
            <summary>
            go to ruleset #8
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet9">
            <summary>
            go to ruleset #9
            </summary> 
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet10">
            <summary>
            go to ruleset #10
            </summary>
        </member>
        <member name="T:GraphSynth.GenerationStatuses">
            <summary>
            Enumerator Declaration for How Generation Ended, GenerationStatus 
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.Unspecified">
            <summary />
        </member>
        <member name="F:GraphSynth.GenerationStatuses.Normal">
            <summary>
            Following a normal cycle through the RCA loop.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.Choice">
            <summary>
            Following the choosing step of the RCA loop.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.CycleLimit">
            <summary>
            Following the a maximum number of cycle through the RCA loop.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.NoRules">
            <summary>
            Following no rules having been recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.TriggerRule">
            <summary>
            Following the application of a trigger rule.
            </summary>
        </member>
        <member name="T:GraphSynth.optimize">
            <summary>
             Enumerator for Search functions that have generality
             to either minimize or maximize (e.g. PNPPS, stochasticChoose). */
            </summary>
        </member>
        <member name="F:GraphSynth.optimize.minimize">
            <summary>
            Minimize in the search - smaller is better.
            </summary>
        </member>
        <member name="F:GraphSynth.optimize.maximize">
            <summary>
            Maximize in the search - bigger is better.
            </summary>
        </member>
        <member name="T:GraphSynth.OptimizeSort">
            <summary>
            A comparer for optimization that can be used for either 
            minimization or maximization.
            </summary>
        </member>
        <member name="M:GraphSynth.OptimizeSort.#ctor(GraphSynth.optimize)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.OptimizeSort"/> class.
            </summary>
            <param name="direction">The direction.</param>
        </member>
        <member name="M:GraphSynth.OptimizeSort.Compare(System.Double,System.Double)">
            <summary>
            Compares two objects and returns a value indicating whether the 
            first one is better than the second one. "Better than" is defined
            by the optimize direction provided in the constructor. In order to
            avoid errors in the sorting, we make sure that only -1 or 1 is 
            returned. If they are equal, we return 1. This makes newer items to
            the list appear before older items. It is slightly more efficient than 
            returning -1 and conforms with the philosophy of always exploring or
            preferring new concepts. See: SA's Metropolis Criteria.
            </summary>
            <returns>
            A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, as shown in the following table.Value Meaning Less than zero<paramref name="x"/> is less than <paramref name="y"/>.Zero<paramref name="x"/> equals <paramref name="y"/>.Greater than zero<paramref name="x"/> is greater than <paramref name="y"/>.
            </returns>
            <param name="x">The first object to compare.</param><param name="y">The second object to compare.</param>
        </member>
        <member name="T:GraphSynth.transfromType">
            <summary>
            Defines the constraint on how shapes/coordinates are transformed. 
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.Prohibited">
            <summary>
            This type of transform is not recognized/performed.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.OnlyX">
            <summary>
            This type of transform is recognized/performed only in the X-direction.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.OnlyY">
            <summary>
            This type of transform is recognized/performed only in the Y-direction.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.BothUniform">
            <summary>
            This type of transform is recognized/performed uniformly in both X and Y.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.BothIndependent">
            <summary>
            This type of transform is recognized/performed in both X and Y independently.
            </summary>
        </member>
        <member name="T:GraphSynth.MyIOPath">
            <summary>
              A simple static class created within a single function - to create relative paths.
            </summary>
        </member>
        <member name="M:GraphSynth.MyIOPath.GetRelativePath(System.String,System.String)">
            <summary>
              Gets the relative path to the target path starting at the "with Respect to" directory.
              The method will add the necessary "..\" to get back to the common directory.
            </summary>
            <param name = "target">The target path.</param>
            <param name = "withRespectTo">The "with respect to" directory.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Search.LindenmayerChooseRCA">
            <summary>
            As stated on the wikipedia page (http://en.wikipedia.org/wiki/L-system)
            "The rules of the L-system grammar are applied iteratively starting 
            from the initial state. As many rules as possible are applied 
            simultaneously, per iteration; this is the distinguishing feature 
            between an L-system and the formal language generated by a formal grammar. 
            If the production rules were to be applied only one at a time, one would 
            quite simply generate a language, rather than an L-system. Thus, 
            L-systems are strict subsets of languages."
            Thus, this is used in the RCA loop to invoke all confluent rules.
            </summary>
        </member>
        <member name="T:GraphSynth.Search.RecognizeChooseApply">
            <summary>
              this is the main file and class of generation. The model adopted is that one should
              create an inherited class of this ABSTRACT class, as has been done for randomChoose, 
              chooseViaHumanGui, etc. This file has gone through a lot of revision to make it 
              general to a wide variety of problems. It should not have to be altered, rather one
              can control aspects of the execution through the ruleSets
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RecognizeChooseApply.rulesets">
            <summary>
              An array of rulesets used in this generation process.
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RecognizeChooseApply.InParallel">
            <summary>
            Gets or sets a value indicating whether [in parallel].
            </summary>
            <value><c>true</c> if [in parallel]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.RecognizeChooseApplyCycle(GraphSynth.Representation.candidate,System.Int32,System.Int32[])">
            <summary>
              Recognizes the choose apply cycle. Here is the main Recognize, Choose, and 
              Apply Generation Cycle. It accepts the host candidate (not graph), the index
              of what ruleSet to invoke, and an array of size equal to the number of ruleSets.
              At the end of the process, it returns the updated candidate. The three step
              process may, however exit at any of five places in the loop, these are described below.
              1. the ruleSet invoked may not have any calls left. This will cause the GenerationStatus
              to be CycleLimit, and the process will execute what is stored in the 3rd position of 
              generationSteps, ruleSet->nextGenerationStep[2], either Stop, Loop, GoToPrevious(ruleSet),
              GoToNext(ruleSet), or GoToRuleSet#
              2. the choice operation has sent a STOP message, or more precisely a negative # or
              a number greater than the list of option. This results in a GenerationStatus of Choice
              and the execution of ruleSet->nextGenerationStep[1] (any of the options stated above).
              3. there are no rules recognized for the graph. This results in a GenerationStatus of
              NoRules and the execution of ruleSet->nextGenerationStep[3] (any of the options above).
              4. A trigger rule has been applied. This results in a GenerationStatus of TriggerRule
              and the execution of ruleSet->nextGenerationStep[4] (any of the options stated above).
              5. the recognize, choose, and apply cycle performed as intended - no abnormal activites.
              This results in a GenerationStatus of Normal and the execution of 
              ruleSet->nextGenerationStep[0] (any of the options stated above).*/
            </summary>
            <param name = "host">The host.</param>
            <param name = "ruleSetIndex">Index of the rule set.</param>
            <param name = "numOfCallsLeft">The num of calls left.</param>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.CallOneRuleOnCandidate(GraphSynth.Representation.candidate,System.Int32)">
            <summary>
              Calls  one rule on candidate - the rule is determined by the choose function.
            </summary>
            <param name = "cand">The cand.</param>
            <param name = "startingRuleSet">The starting rule set.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.GenerateAllNeighbors(GraphSynth.Representation.candidate,System.Boolean,System.Int32)">
            <summary>
              Generates all neighbors of the current.
            </summary>
            <param name = "current">The current.</param>
            <param name = "IncludingParent">if set to <c>true</c> [including parent].</param>
            <param name = "MaxNumber">The max number.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.GenerateOneCandidate(GraphSynth.Representation.candidate,System.Int32)">
            <summary>
              Generates one candidate. A simple function for invoking the RecognizeChooseApplyCycle.
              That function is protected so we invoke it through a function like this.
            </summary>
            <param name = "cand">The cand to build upon (if null, then the seed will be used).</param>
            <param name = "startingRuleSet">The starting rule set (if unspecified then the candidate's active ruleset will be used.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Search.RecognizeChooseApply"/> class.
            </summary>
            <param name="seed">The _seed.</param>
            <param name="rulesets">The _rulesets.</param>
            <param name="maxNumOfCalls">The _max num of calls.</param>
            <param name="display">if set to <c>true</c> [_display].</param>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.#ctor(GraphSynth.GlobalSettings,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Search.RecognizeChooseApply"/> class.
            </summary>
            <param name="settings">The settings.</param>
            <param name="displayIntermediateGraphs">if set to <c>true</c> [display intermediate graphs].</param>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
              Chooses the specified options. Given the list of options and the candidate, 
              determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name = "options">The options.</param>
            <param name = "cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.choose(GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
              Chooses the specified option. Given that the rule has now been chosen, determine
              the values needed by the rule to properly apply it to the candidate, cand. The 
              array of double is to be determined by parametric apply rules written in 
              complement C# files for the ruleSet being used.
            </summary>
            <param name = "opt">The opt.</param>
            <param name = "cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.AssignOptionConfluence(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
              Create lists on integers within each option that indicates what other
              options in that list it is confluent with. As discussed below confluence
              is commutative which saves a little time in this function, but it is not
              transitive - meaning is A is confluent with B and C. It is not necessarily
              true that B is confluent with C.
            </summary>
            <param name = "options">The list of options to assign confluence</param>
            <param name="cand"></param>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.MakeInvalidationMatrix(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
            Makes the invalidation matrix.
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.ClearInvalidationMatrix">
            <summary>
            Clears the invalidation matrix.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.doesPInvalidateQ(GraphSynth.Representation.option,GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
              Predicts whether the option p is invalidates option q.
              This invalidata is a tricky thing. For the most part, this function 
              has been carefully coded to handle almost all cases. The only exceptions
              are from what the additional recognize and apply functions require or modify.
              This is handled by actually testing to see if this is true.
            </summary>
            <param name="p">The p.</param>
            <param name="q">The q.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.fullInvalidationCheck(GraphSynth.Representation.option,GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
            Does a full invalidation check through empirical evidence. That is, it makes
            a copy of the graph and tests to see if this is true.
            </summary>
            <param name="p">The p.</param>
            <param name="q">The q.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.display">
            <summary>
            a simple Boolean used for debugging or interactive generation. If true then
            the host will be replotted after each apply action.
            </summary>
            <value><c>true</c> if display; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.choice">
            <summary>
              Gets or sets the integer choice which is used in the main loop as well as in 
              various implementation of choose. As a result we define it as global to the class.
            </summary>
            <value>The choice.</value>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.maxNumOfCalls">
            <summary>
              Gets or sets the array of the maximum number of calls to make in each ruleset.
              This is not cumulative - if you return to a previous ruleset, the counter is 
              reset. It is copied to the numOfCallsLeft at the beginning of the RCACycle into 
              the numOfCallsLeft slot.
            </summary>
            <value>The max num of calls.</value>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.seed">
            <summary>
              Gets or sets the seed. Often the same seed is used as a starting point with the 
              generation process. That seed is stored here as a global field of the class.
            </summary>
            <value>The seed.</value>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.numOfRuleSets">
            <summary>
              Gets or sets the num of rule sets.
            </summary>
            <value>The num of rule sets.</value>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.InvalidationMatrix">
            <summary>
            Gets the invalidation matrix.
            </summary>
            <value>The invalidation matrix.</value>
        </member>
        <member name="M:GraphSynth.Search.LindenmayerChooseRCA.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified options. Given the list of options and the candidate,
            determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.LindenmayerChooseRCA.choose(GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified option. Given that the rule has now been chosen, determine
            the values needed by the rule to properly apply it to the candidate, cand. The
            array of double is to be determined by parametric apply rules written in
            complement C# files for the ruleSet being used.
            </summary>
            <param name="opt">The opt.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.LindenmayerChooseRCA.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Search.LindenmayerChooseRCA"/> class.
            </summary>
            <param name="seed">The seed.</param>
            <param name="rulesets">The rulesets.</param>
            <param name="numCalls">The num calls.</param>
            <param name="display">if set to <c>true</c> [display].</param>
        </member>
        <member name="T:GraphSynth.Search.RandomChooseRCA">
            <summary>
            An overload for the RCA class that randomly chooses options. 
            
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RandomChooseRCA.rnd">
            <summary>
            a random number generator to be used in choose.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseRCA.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified options. Given the list of options and the candidate,
            determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseRCA.choose(GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified option. Given that the rule has now been chosen, determine
            the values needed by the rule to properly apply it to the candidate, cand. The
            array of double is to be determined by parametric apply rules written in
            complement C# files for the ruleSet being used.
            </summary>
            <param name="opt">The opt.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseRCA.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Search.RandomChooseRCA"/> class.
            </summary>
            <param name="seed">The seed.</param>
            <param name="rulesets">The rulesets.</param>
            <param name="numCalls">The num calls.</param>
            <param name="display">if set to <c>true</c> [display].</param>
        </member>
        <member name="T:GraphSynth.Search.RandomChooseWithUndoRCA">
            <summary>
            An overload for the RCA class that randomly chooses options. In this 
            version, it can also randomly choose to undo the last option (by choosing
            -1).
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RandomChooseWithUndoRCA.rnd">
            <summary>
            a random number generator to be used in choose.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseWithUndoRCA.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified options. Given the list of options and the candidate,
            determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseWithUndoRCA.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Search.RandomChooseWithUndoRCA"/> class.
            </summary>
            <param name="_seed">The _seed.</param>
            <param name="_rulesets">The _rulesets.</param>
            <param name="_maxNumOfCalls">The _max num of calls.</param>
            <param name="_display">if set to <c>true</c> [_display].</param>
        </member>
        <member name="T:GraphSynth.Search.SearchProcess">
            <summary>
              The abstract class that must be inherited in the Search plugins.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.#ctor(GraphSynth.GlobalSettings)">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Search.SearchProcess"/> class.
            </summary>
            <param name="settings">The settings.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:GraphSynth.Search.SearchProcess"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.RunSearchProcess">
            <summary>
              Runs the search process.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.Run">
            <summary>
              Runs this instance.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.transferLmappingToChild(GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph)">
            <summary>
              A necessary function when multiple (more than one) application of a rule is applied
              to a host. The function reads in the child graph (often a copy of the current), 
              the current graph, and the Lmapping. The Lmapping is changed but the child and current are
              unaffected.
            </summary>
            <param name = "child">The child.</param>
            <param name = "current">The current.</param>
            <param name = "Lmapping">The lmapping.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.nextRuleSet(System.Int32,GraphSynth.GenerationStatuses)">
            <summary>
              A helper function to RecognizeChooseApplyCycle. This function returns what the new ruleSet
              will be. Here the enumerator nextGenerationSteps and GenerationStatuses is used to great
              affect. Understand that if a negative number is returned, the cycle will be stopped.
            </summary>
            <param name = "ruleSetIndex">Index of the rule set.</param>
            <param name = "status">The status.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.addNewCandtoPareto(GraphSynth.Representation.candidate,System.Collections.Generic.List{GraphSynth.Representation.candidate})">
            <summary>
              Adds the new candidate to the pareto set.
            </summary>
            <param name = "c">The c.</param>
            <param name = "ParetoCands">The pareto cands.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.addChildToSortedCandList(System.Collections.Generic.List{GraphSynth.Representation.candidate},GraphSynth.Representation.candidate)">
            <summary>
              Adds the child to sorted candidate list based on the value of f0 (performanceParams[0]).
              The OptimizeDirection is not used as the list is always sorted from lowest to highest.
            </summary>
            <param name = "candidates">The candidates.</param>
            <param name = "child">The child.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.dominates(GraphSynth.Representation.candidate,GraphSynth.Representation.candidate)">
            <summary>
              Does c1 dominate c2?
            </summary>
            <param name = "c1">the subject candidate, c1 (does this dominate...).</param>
            <param name = "c2">the object candidate, c2 (is dominated by).</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.dominates(GraphSynth.Representation.candidate,GraphSynth.Representation.candidate,GraphSynth.optimize[])">
            <summary>
              Does candidate, c1, dominate c2?
            </summary>
            <param name = "c1">The c1.</param>
            <param name = "c2">The c2.</param>
            <param name = "optDirections">The opt directions.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.Save(System.String,System.Object,System.Boolean)">
            <summary>
            Saves the specified filename.
            </summary>
            <param name="filename">The filename.</param>
            <param name="o">The o.</param>
            <param name="SuppressWarnings">if set to <c>true</c> [suppress warnings].</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.SaveCandidates(System.String,System.Collections.IList,System.Boolean,System.Boolean)">
            <summary>
            Saves the candidates.
            </summary>
            <param name="filename">The filename base, a unique number is added for each
            candidate (plus the timestamp, if true).</param>
            <param name="candidates">The candidates.</param>
            <param name="SaveToOutputDir">if set to <c>true</c> [save to output dir].</param>
            <param name="timeStamp">if set to <c>true</c> [time stamp].</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.Open(System.String,System.Boolean)">
            <summary>
            Opens the specified filename.
            </summary>
            <param name="filename">The filename.</param>
            <param name="SuppressWarnings">if set to <c>true</c> [suppress warnings].</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.seedGraph">
            <summary>
              Gets the seed graph defined in settings.
            </summary>
            <value>The seed graph.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.seedCandidate">
            <summary>
              Gets the seed candidate.
            </summary>
            <value>The seed candidate.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.rulesets">
            <summary>
              Gets the rulesets defined in the settings as an array.
            </summary>
            <value>The rulesets.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.RequireSeed">
            <summary>
              Gets or sets a value indicating whether [require seed].
            </summary>
            <value><c>true</c> if [require seed]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.RequiredNumRuleSets">
            <summary>
              Gets or sets the required num rule sets.
            </summary>
            <value>The required num rule sets.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.AutoPlay">
            <summary>
              Gets or sets a value indicating whether [auto play].
            </summary>
            <value><c>true</c> if [auto play]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.settings">
            <summary>
              Gets the settings defined for the problem (as saved in GraphSynthSettings.gsconfig
              and as specified by the user in Edit->Settings).
            </summary>
            <value>The settings.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.text">
            <summary>
              Gets the text describing that is displayed in the menu. It must be overridden in the methods.
            </summary>
            <value>The text.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.OptimizeDirection">
            <summary>
              Gets or sets the optimize direction for all performance parameters.
              This is not a necessity, and specific search process might required some
              performance parameters to be maximized while others are minimized.
            </summary>
            <value>The optimize direction.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.inputDirectory">
            <summary>
            Gets or sets the input directory.
            </summary>
            <value>The input directory.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.outputDirectory">
            <summary>
            Gets or sets the output directory.
            </summary>
            <value>The output directory.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.rulesDirectory">
            <summary>
            Gets or sets the rules directory.
            </summary>
            <value>The rules directory.</value>
        </member>
        <member name="T:GraphSynth.ShapeData">
            <summary>
            The ShapeData class stores the data for how to display a particular graph element:
            node, arc, or hyperarc. At this level, it is essentially an XML string of data. It is
            similar to the GraphSynth.CustomControls.DisplayShape, which inherits from this class.
            That class is specific to the WPF viewer programs.
            This is a new class as of October 2011. It combines three previous classes (IDisplayShape,
            ShapeKey, and DisplayStringShape [from GraphSynthConsole]) into a single class.
            </summary>
        </member>
        <member name="F:GraphSynth.ShapeData.Element">
            <summary>
            The graph element that this data is representing
            </summary>
        </member>
        <member name="F:GraphSynth.ShapeData._stringShape">
            <summary>
            This protected field describes the shape.
            </summary>
        </member>
        <member name="M:GraphSynth.ShapeData.#ctor(System.String,GraphSynth.Representation.graphElement)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.ShapeData"/> class.
            </summary>
            <param name="s">The s.</param>
            <param name="element">The element.</param>
        </member>
        <member name="M:GraphSynth.ShapeData.#ctor(GraphSynth.Representation.graphElement)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.ShapeData"/> class.
            </summary>
            <param name="element">The element.</param>
        </member>
        <member name="M:GraphSynth.ShapeData.op_Implicit(GraphSynth.ShapeData)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:GraphSynth.ShapeData"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="x">The ShapeData, x.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:GraphSynth.ShapeData.Copy(GraphSynth.Representation.graphElement)">
            <summary>
            Copies the specified element.
            </summary>
            <param name="element">The element.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.ShapeData.TransformMatrix">
            <summary>
            Gets or sets the transform matrix.
            </summary>
            <value>
            The transform matrix.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Fill">
            <summary>
            Gets or sets the fill.
            </summary>
            <value>
            The fill.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Stroke">
            <summary>
            Gets or sets the stroke.
            </summary>
            <value>
            The stroke.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.StrokeThickness">
            <summary>
            Gets or sets the stroke thickness.
            </summary>
            <value>
            The stroke thickness.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Height">
            <summary>
            Gets or sets the height.
            </summary>
            <value>
            The height.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Width">
            <summary>
            Gets or sets the width.
            </summary>
            <value>
            The width.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.ScreenX">
            <summary>
            Gets or sets the screen X.
            </summary>
            <value>
            The screen X.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.ScreenY">
            <summary>
            Gets or sets the screen Y.
            </summary>
            <value>
            The screen Y.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Tag">
            <summary>
            Gets or sets the tag.
            </summary>
            <value>
            The tag.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Shape">
            <summary>
            Gets the shape.
            </summary>
        </member>
        <member name="F:GraphSynth.MatrixMath.epsilon">
            <summary>
              This is used below in the close enough to zero booleans to match points
              (see below: sameCloseZero). In order to avoid strange round-off issues - 
              even with doubles - I have implemented this function when comparing the
              position of points (mostly in checking for a valid transformation (see
              ValidTransformation) and if other nodes comply (see otherNodesComply).
            </summary>
        </member>
    </members>
</doc>
