<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GraphSynth.BaseClasses</name>
    </assembly>
    <members>
        <member name="T:GraphSynth.BasicFiler">
            <summary>
              This method saves and opens basic graphs and rules (doesn't include WPF shapes)
              as well as rulesets, which are the same as in earlier versions of GraphSynth.
            </summary>
        </member>
        <member name="M:GraphSynth.BasicFiler.#ctor(System.String,System.String,System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.BasicFiler" /> class.
            </summary>
            <param name = "iDir">The input directory.</param>
            <param name = "oDir">The output directory.</param>
            <param name = "rDir">The rules directory.</param>
        </member>
        <member name="F:GraphSynth.BasicFiler.IgnorablePrefix">
            <summary>
              This constant is used to tell other XML parsers (namely XAML displayers)
              to ignore elements that are prefaced with this.
            </summary>
        </member>
        <member name="P:GraphSynth.BasicFiler.inputDirectory">
            <summary>
              Gets or sets the input directory.
            </summary>
            <value>The input directory.</value>
        </member>
        <member name="P:GraphSynth.BasicFiler.outputDirectory">
            <summary>
              Gets or sets the output directory.
            </summary>
            <value>The output directory.</value>
        </member>
        <member name="P:GraphSynth.BasicFiler.rulesDirectory">
            <summary>
              Gets or sets the rules directory.
            </summary>
            <value>The rules directory.</value>
        </member>
        <member name="M:GraphSynth.BasicFiler.Save(System.String,System.Object,System.Boolean)">
            <summary>
              Saves the object, o, to the specified filename.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "o">The object to save.</param>
            <param name = "SuppressWarnings">if set to <c>true</c> [suppress warnings].</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.Open(System.String,System.Boolean)">
            <summary>
              Opens the list of objects at the specified filename.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "SuppressWarnings">if set to <c>true</c> [suppresses warnings].</param>
            <returns>an array of opened objects</returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveGraph(System.String,GraphSynth.Representation.designGraph)">
            <summary>
              Saves the graph.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "graph1">The graph1.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SerializeGraphToXml(GraphSynth.Representation.designGraph)">
            <summary>
              Serializes the graph to XML.
            </summary>
            <param name = "graph1">The graph1.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenGraph(System.String)">
            <summary>
              Opens the graph.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.DeSerializeGraphFromXML(System.String)">
            <summary>
              Deserialize graph from XML.
            </summary>
            <param name = "xmlString">The XML string.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.removeNullWhiteSpaceEmptyLabels(GraphSynth.Representation.designGraph)">
            <summary>
            Removes the null white space empty labels.
            </summary>
            <param name="g">The g.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.RestoreDisplayShapes(GraphSynth.Representation.designGraph)">
            <summary>
              Restores the display shapes.
            </summary>
            <param name = "graph">The graph.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveRule(System.String,GraphSynth.Representation.grammarRule)">
            <summary>
              Saves the rule.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "ruleToSave">The rule to save.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SerializeRuleToXml(GraphSynth.Representation.grammarRule)">
            <summary>
              Serializes the rule to XML.
            </summary>
            <param name = "ruleToSave">The rule to save.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenRule(System.String)">
            <summary>
              Opens the rule.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.DeSerializeRuleFromXML(System.String)">
            <summary>
              Deserialize rule from XML.
            </summary>
            <param name = "xmlString">The XML string.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.checkRule(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks the rule with some issues that may have been overlooked.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.NotExistElementsinKR(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks to see that the negative elements are not stored in K and R.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.KarcsChangeDirection(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks that the K arcs do not change direction.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.NumKElements(GraphSynth.Representation.grammarRule)">
            <summary>
            Checks that the number of K elements is greater than 0.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.ValidateFreeArcEmbeddingRules(GraphSynth.Representation.grammarRule)">
            <summary>
            Validates the free arc embedding rules.
            </summary>
            <param name="gR">The grammar rule.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveRuleSet(System.String,GraphSynth.Representation.ruleSet)">
            <summary>
              Saves the rule set.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "ruleSetToSave">The rule set to save.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenRuleSet(System.String)">
            <summary>
              Opens the rule set.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.LoadRulesFromFileNames(System.String,System.Collections.Generic.List{System.String},System.Int32@)">
            <summary>
              Loads the rules from file names.
            </summary>
            <param name = "ruleDir">The rule dir.</param>
            <param name = "ruleFileNames">The rule file names.</param>
            <param name = "numLoaded">The num loaded.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.BasicFiler.ReloadSpecificRule(GraphSynth.Representation.ruleSet,System.Int32)">
            <summary>
              Reloads the specific rule.
            </summary>
            <param name = "rs">The rs.</param>
            <param name = "i">The i.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveCandidates(System.String,System.Collections.IList,System.Boolean,System.Boolean)">
            <summary>
            Saves the candidate.
            </summary>
            <param name="filename">The filename.</param>
            <param name="candidates">The candidates.</param>
            <param name="SaveToOutputDir">if set to <c>true</c> [save to output dir].</param>
            <param name="timeStamp">if set to <c>true</c> [time stamp].</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.SaveCandidate(System.String,GraphSynth.Representation.candidate)">
            <summary>
              Saves the candidate.
            </summary>
            <param name = "filename">The filename.</param>
            <param name = "c1">The c1.</param>
        </member>
        <member name="M:GraphSynth.BasicFiler.OpenCandidate(System.String)">
            <summary>
              Opens the candidate.
            </summary>
            <param name = "filename">The filename.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Representation.arc">
            <summary>
              One of the two basic classes for a graph is the arc or edge that connects
              two and only two elements of the node class.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.arc.from">
            <summary>
              Each arc connects to two and only two nodes, these are stored in protected elements.
              This is a field for the node the arc is coming from.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.arc.to">
            <summary>
              Each arc connects to two and only two nodes, these are stored in protected elements.
              This is a field for the node the arc is going to.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.arc.From">
            <summary>
              Gets or sets the connected node, From.
            </summary>
            <value>the node the arc is coming from.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.To">
            <summary>
              Gets or sets  the connected node, To.
            </summary>
            <value>the node the arc is going to.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.XmlFrom">
            <summary>
              Gets or sets the name of the node that the arc is coming from.
              It is necessary to do this, otherwise the serializer would rewrite 
              the actual node to the file (*.gxml file).
            </summary>
            <value>The XML from.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.XmlTo">
            <summary>
              Gets or sets the  NAME of the node that the arc is going to.
            </summary>
            <value>The XML to.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.directed">
            <summary>
              Gets or sets a value indicating whether this <see cref = "T:GraphSynth.Representation.arc" /> is directed.
            </summary>
            <value><c>true</c> if directed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.doublyDirected">
            <summary>
              Gets or sets a value indicating whether [doubly directed].
            </summary>
            <value><c>true</c> if [doubly directed]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.arc.length">
            <summary>
              Gets the straightline distance between the two connecting nodes.
            </summary>
            <value>The length.</value>
        </member>
        <member name="M:GraphSynth.Representation.arc.otherNode(GraphSynth.Representation.node)">
            <summary>
              Given one connecting node, this function returns
              the other node connected to this arc.
            </summary>
            <param name = "node1">One known node.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.arc.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.arc"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.arc.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.arc"/> class.
            </summary>
            <param name="newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.arc.copy">
            <summary>
              Copies this instance of an arc and returns the copy.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.arc.copy(GraphSynth.Representation.arc)">
            <summary>
              Copies this.arc into the argument copyOfArc.
            </summary>
            <param name = "copyOfArc">The copy of arc.</param>
        </member>
        <member name="T:GraphSynth.Representation.edge">
            <summary>
              Originally, I created a separate edge and vertex class to allow for the future expansion
              of GraphSynth into shape grammars. I now have decided that the division is not useful, 
              since it simply deprived nodes of X,Y,Z positions. Many consider edge and arc, and vertex
              and node to be synonymous anyway but I prefer to think of edges and vertices as arcs and 
              nodes with spatial information. At any rate there is no need to have these inherited 
              classes, but I keep them for backwards-compatible purposes.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.edge.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.edge"/> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="M:GraphSynth.Representation.edge.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.edge"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.edge.copy">
            <summary>
              Copies this instance of an arc and returns the copy.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="T:GraphSynth.Representation.candidate">
            <summary>
              The candidate class is a wrapper to designGraph. While the graph is
              essentially what we are interested in, the candidate also includes
              some other essential information. For example, what is the worth
              of the graph (performance parameters), and what is the recipe, or
              list of options that were called to create the graph (recipe).
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.candidate" /> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.#ctor(GraphSynth.Representation.designGraph,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.candidate" /> class.
            </summary>
            <param name = "_graph">The _graph.</param>
            <param name = "numRuleSets">The num rule sets.</param>
        </member>
        <member name="F:GraphSynth.Representation.candidate.prevStates">
            <summary>
            All the previous states of the graph are stored within a candidate. This makes candidate a
              'heavy' class, but it allows us to go back to how it existed quickly.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.candidate.GenerationStatus">
            <summary>
              Just like the discussion for activeRuleSetIndex, GenerationStatus stores what has
              happened during the RCA generation loop. The is one for each ruleSet as each ruleSet
              may have ended in a different way.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.candidate.performanceParams">
            <summary>
              a list of numbers used to define a candidate's worth. While this is a public field, 
              it may be less buggy to write code using the properties f0, f1, f2, f3, and f4 stored
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.candidate.recipe">
            <summary>
              the recipe is a list of all the options that were chosen to create the candidate.
              Option is stored under representation. Each option contains, the rulesetindex,
              the number of the rule, a reference to the rule, and the location of where the rule
              was applied.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.candidate.graph">
            <summary>
              Gets or sets the graph. Stating a candidate's graph is simply it's current state. 
              However, if this property is used in to set the graph to a new one, then we move 
              the current state onto the prevStates list.
            </summary>
            <value>The graph.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.graphFileName">
            <summary>
              Gets or sets the name of the graph file.
            </summary>
            <value>The name of the graph file.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.activeRuleSetIndex">
            <summary>
              Gets or sets the index of the active rule set. the activeRuleSetIndex is set during 
              the recognize->choose->apply generation. It is very similar to the candidate property, 
              lastRuleSetIndex however in certain subtle yet important occasions the two will differ. 
              This will happen if an RCA loop starts but doesn't complete apply. This happens if 
              max number of calls is reached, if choice is STOP, or no rules are recognized.
            </summary>
            <value>The index of the active rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.age">
            <summary>
              Gets or sets the age. This is an arbitrary value set by the search process. 
              Likely it will be set to the # of iterations the candidate has existed in.
            </summary>
            <value>The age.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.numRulesCalled">
            <summary>
              Gets the number of rules called (same of length of recipe.
            </summary>
            <value>The num rules called.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.lastRuleSetIndex">
            <summary>
              Gets the rule set index of the last option.
            </summary>
            <value>The last index of the rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f0">
            <summary>
              Gets or sets the first performance parameter.
            </summary>
            <value>The f0.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f1">
            <summary>
              Gets or sets the second performance parameter.
            </summary>
            <value>The f1.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f2">
            <summary>
              Gets or sets the third performance parameter.
            </summary>
            <value>The f2.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f3">
            <summary>
              Gets or sets the fourth performance parameter.
            </summary>
            <value>The f3.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.f4">
            <summary>
              Gets or sets the fifth performance parameter.
            </summary>
            <value>The f4.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.ruleNumbersInRecipe">
            <summary>
              Gets the rule numbers in recipe as an array of integers.
            </summary>
            <value>The rule numbers in recipe.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.ruleSetIndicesInRecipe">
            <summary>
              Gets the rule set indices in recipe as an array of integers.
            </summary>
            <value>The rule set indices in recipe.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.optionNumbersInRecipe">
            <summary>
              Gets the option numbers in recipe as an array of integers.
            </summary>
            <value>The option numbers in recipe.</value>
        </member>
        <member name="P:GraphSynth.Representation.candidate.parametersInRecipe">
            <summary>
              Gets the parameter decisions of the recipe. This is a List the
              same length as recipe, but each element is an array of double values.
            </summary>
            <value>The parameters in recipe.</value>
        </member>
        <member name="F:GraphSynth.Representation.candidate.designParameters">
            <summary>
              a list of numbers used to define a candidate's design or decision variables. This is
              typically used to define parameters within the graph.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.saveCurrent">
            <summary>
              Saves a copy of the current state to the list of previous states.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.addToRecipe(GraphSynth.Representation.option)">
            <summary>
              Adds to recipe. This is called (currently only) from the RCA loop. This happens
              directly after the rule is APPLIED. A rule application updates
              the currentstate, so this correspondingly adds the option to the recipe.
            </summary>
            <param name = "currentOpt">The currentrule.</param>
        </member>
        <member name="M:GraphSynth.Representation.candidate.undoLastRule">
            <summary>
              Undoes the last rule. This is perhaps the whole reason previous states are used.
              Rules cannot be guaranteed to work in reverse as they work
              forward, so this simply resets the candidate to how it looked
              prior to calling the last rule.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.candidate.copy">
            <summary>
              Copies this instance of a candidate. Very similar to designGraph copy.
              We make sure to not do a shallow copy (ala Clone) since we are unsure
              how each candidate may be changed in the future.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Representation.designGraph">
            <summary>
              The quintessential class in all of this research. The graph of nodes,
              arcs, and hyperarcs is called a designGraph. The use of the word design
              is a carry-over from other research, but indicates that GraphSynth is really
              about designing with graphs.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.name">
            <summary>
              Gets or sets the name.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.comment">
            <summary>
              Gets or sets the comment.
            </summary>
            <value>The comment.</value>
        </member>
        <member name="F:GraphSynth.Representation.designGraph._globalLabels">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.designGraph._globalVariables">
            <summary />
        </member>
        <member name="P:GraphSynth.Representation.designGraph.globalLabels">
            <summary>
              Gets the global labels.
            </summary>
            <value>The global labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.globalVariables">
            <summary>
              Gets the global variables.
            </summary>
            <value>The global variables.</value>
        </member>
        <member name="F:GraphSynth.Representation.designGraph._arcs">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.designGraph._hyperarcs">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.designGraph._nodes">
            <summary />
        </member>
        <member name="P:GraphSynth.Representation.designGraph.arcs">
            <summary>
              Gets or sets the arcs.
            </summary>
            <value>The arcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.nodes">
            <summary>
              Gets the nodes.
            </summary>
            <value>The nodes.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.hyperarcs">
            <summary>
              Gets the hyperarcs.
            </summary>
            <value>The hyperarcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.DegreeSequence">
            <summary>
            Gets the degree sequence.
            </summary>
            <value>The degree sequence.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.HyperArcDegreeSequence">
            <summary>
            Gets the hyper arc degree sequence.
            </summary>
            <value>The hyper arc degree sequence.</value>
        </member>
        <member name="P:GraphSynth.Representation.designGraph.Item(System.String)">
            <summary>
              Gets the <see cref = "T:GraphSynth.Representation.graphElement" /> with the specified name.
              This indexer is to make it easier to find a particular node, arc, or hyperArc. Note 
              that it only returns a graphElement, so the user must explicitly cast it as a node,
              arc, or hyperArc.
            </summary>
            <value></value>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addArc(GraphSynth.Representation.node,GraphSynth.Representation.node,System.String,System.Type)">
            <summary>
            Creates and Adds a new arc to the graph, and connects it between
            the fromNode and the toNode
            </summary>
            <param name="fromNode">From node.</param>
            <param name="toNode">To node.</param>
            <param name="newName">The name.</param>
            <param name="arcType">Type of the arc.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addArc(GraphSynth.Representation.arc,GraphSynth.Representation.node,GraphSynth.Representation.node)">
            <summary>
              Adds the arc to the graph and connects it between these two nodes.
            </summary>
            <param name = "newArc">The new arc.</param>
            <param name = "fromNode">From node.</param>
            <param name = "toNode">To node.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.removeArc(GraphSynth.Representation.arc)">
            <summary>
              Removes the arc and references to it in the nodes.
            </summary>
            <param name = "arcToRemove">The arc to remove.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addNode(System.String,System.Type)">
            <summary>
              Creates and Adds a new node of called newName of type nodeType.
            </summary>
            <param name = "newName">The new name.</param>
            <param name = "nodeType">Type of the node.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addNode(GraphSynth.Representation.node)">
            <summary>
              Adds the node to the graph. This is very simple, and is in fact identical to
              doing graph.nodes.Add(n);
            </summary>
            <param name = "n">The n.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.removeNode(GraphSynth.Representation.node,System.Boolean)">
            <summary>
              Removes the node. Removing a node is a little more complicated than removing arcs
              since we need to decide what to do with dangling arcs. As a result there are two 
              booleans that specify how to handle the arcs. removeArcToo will simply delete the
              attached arcs if true, otherwise it will leave them dangling (default is false).
              removeNodeRef will change the references within the attached arcs to null if set 
              to true, or will leave them if false (default is true).
            </summary>
            <param name = "nodeToRemove">The node to remove.</param>
            <param name = "removeNodeRef">if set to <c>true</c> remove reference to this node in the arcs.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addHyperArc(System.Collections.Generic.List{GraphSynth.Representation.node},System.String,System.Type)">
            <summary>
            Creates and Adds a new hyperarc to the graph, and connects it
            to the stated nodes.
            </summary>
            <param name="attachedNodes">The nodes.</param>
            <param name="newName">The new name.</param>
            <param name="hyperarcType">The t.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.addHyperArc(GraphSynth.Representation.hyperarc,System.Collections.Generic.List{GraphSynth.Representation.node})">
            <summary>
            Adds the arc to the graph and connects it between these nodes.
            </summary>
            <param name="newArc">The new arc.</param>
            <param name="attachedNodes">The nodes.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.removeHyperArc(GraphSynth.Representation.hyperarc)">
            <summary>
            Removes the hyper arc.
            </summary>
            <param name="arcToRemove">The arc to remove.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.designGraph" /> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.#ctor(System.Collections.Generic.IEnumerable{GraphSynth.Representation.node},System.Collections.Generic.IEnumerable{GraphSynth.Representation.arc},System.Collections.Generic.IEnumerable{GraphSynth.Representation.hyperarc})">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.designGraph"/> class.
            currently this constructor is used within the recognize function of the
            grammar rule to establish each of the recognized locations.
            </summary>
            <param name="newNodes">The new nodes.</param>
            <param name="newArcs">The new arcs.</param>
            <param name="newHyperArcs">The new hyper arcs.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.CreateRandomGraph(System.Int32,System.Int32)">
            <summary>
            Creates a random graph that takes two parameters: the number of nodes, 
            and the average degree. Note: that there is no guarantee that the graph 
            will be connected.
            </summary>
            <param name = "numNodes">The number of nodes.</param>
            <param name = "aveDegree">The average degree.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.CreateCompleteGraph(System.Int32)">
            <summary>
              Creates a complete graph where every node is connected to every
              other node by an arc.
            </summary>
            <param name="numNodes">The number of nodes.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.CreateEmptyLocationGraph(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an empty location graph used in recognition.
            </summary>
            <param name="numNodes">The num nodes.</param>
            <param name="numArcs">The num arcs.</param>
            <param name="numHyperArcs">The num hyper arcs.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.copy(System.Boolean)">
            <summary>
              Copies the specified make deep copy.
            </summary>
            <param name = "MakeDeepCopy">if set to <c>true</c> [make deep copy].</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.makeUniqueNodeName(System.String)">
            <summary>
              Makes a unique name for a node.
            </summary>
            <param name = "stub">The stub.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.makeUniqueArcName(System.String)">
            <summary>
              Makes a unique name for an arc.
            </summary>
            <param name = "stub">The stub.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.makeUniqueHyperArcName(System.String)">
            <summary>
            Makes the name of the unique hyper arc.
            </summary>
            <param name="stub">The stub.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.RepairGraphConnections">
            <summary>
              Internally connects the graph.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.replaceNodeWithInheritedType(GraphSynth.Representation.node,System.Type)">
            <summary>
            Replaces the type of the node with inherited.
            </summary>
            <param name="origNode">The orig node.</param>
            <param name="newType">The new type.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.replaceArcWithInheritedType(GraphSynth.Representation.arc,System.Type)">
            <summary>
            Replaces the type of the arc with inherited.
            </summary>
            <param name="origArc">The orig arc.</param>
            <param name="newType">The new type.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.replaceHyperArcWithInheritedType(GraphSynth.Representation.hyperarc,System.Type)">
            <summary>
            Replaces the type of the arc with inherited.
            </summary>
            <param name="origArc">The orig arc.</param>
            <param name="newType">The new type.</param>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.checkForRepeatNames">
            <summary>
              Checks for repeat names.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.designGraph.Equals(System.Object,System.Boolean)">
            <summary>
            Overrides the object method to check all details of the graphs to see
            if they are identical. It is potentially time-consuming as it makes
            rules and assigns the graphs as the L of the rule, and then performs
            the "recognize" function on the other graph.
            </summary>
            <param name="obj">The other graph to compare to this one.</param>
            <param name="contentsOfGraphAreEqual">if set to <c>true</c> then check that contents of graph are equal even though they occupy different memory.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:GraphSynth.Representation.graphElement">
            <summary>
              The base class of node, arc, and hyperarc. It simply captures the basic
              qualities that all includes - mainly a list of labels.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.name">
            <summary>
              Gets or sets the name of the node or arc. All names must be distinct 
              within a given graph in order to correctly serialize and de-
              serialize the graph from the XML (*.gxml) file.
            </summary>
            <value>The name string.</value>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.extraData">
            <summary>
              Gets or sets the old data. In order to be compatible with previous versions,
              this oldData object will be used to catch old files that use screenX and 
              screenY instead of the new format.
            </summary>
            <value>The old data.</value>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.DisplayShape">
            <summary>
              Gets or sets the display shape.
            </summary>
            <value>The display shape.</value>
        </member>
        <member name="F:GraphSynth.Representation.graphElement._localLabels">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.graphElement._localVariables">
            <summary />
        </member>
        <member name="P:GraphSynth.Representation.graphElement.localLabels">
            <summary>
              Gets the local labels.
            </summary>
            <value>The local labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.graphElement.localVariables">
            <summary>
              Gets the local variables.
            </summary>
            <value>The local variables.</value>
        </member>
        <member name="M:GraphSynth.Representation.graphElement.copy(GraphSynth.Representation.graphElement)">
            <summary>
              Copies this graphElement data into the copyOfElt.
            </summary>
            <param name = "copyOfElt">The copy of elt.</param>
        </member>
        <member name="M:GraphSynth.Representation.graphElement.setLabel(System.Int32,System.String)">
            <summary>
              Sets the label. The following two functions are not properties, but work on 
              a similar philosophy. These are like the f0, f1, etc. properties in candidate.
              Here we want to set a label but we are unsure whether the list of local labels
              is long enough. The while loop insures that there are enough items of list, 
              before adding the label. */
            </summary>
            <param name = "index">The index.</param>
            <param name = "label">The label.</param>
        </member>
        <member name="M:GraphSynth.Representation.graphElement.setVariable(System.Int32,System.Double)">
            <summary>
              Sets the variable. Like the function above, here we want to set a variable but 
              we are unsure whether the list of local labels is long enough. The while loop 
              insures that there are enough items of list, before adding the label.
            </summary>
            <param name = "index">The index.</param>
            <param name = "var">The var.</param>
        </member>
        <member name="T:GraphSynth.Representation.hyperarc">
            <summary>
              In the spring of 2010, it was decided to introduce a third basic element
              to the graph: a hyperarc. A hyperarc is an arc that connects an arbitrary
              number of nodes. It does not have a sense of direction like an arc (i.e. all
              hyperarcs are undirected), it does not have a head/tail or to/from distinction
              and it does not have a length. In a sense it has more in common with the node
              than the arc - as such it was decided not to override the arc class.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.hyperarc._nodes">
            <summary />
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.nodes">
            <summary>
              Gets the list of attaced nodes.
            </summary>
            <value>The nodes.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.XmlNodes">
            <summary>
              Gets or sets the name of the node that the arc is coming from.
              It is necessary to do this, otherwise the serializer would rewrite 
              the actual node to the file (*.gxml file).
            </summary>
            <value>The XML from.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.degree">
            <summary>
              Gets the degree of the hyperarcs - the number of nodes that it connects to.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="P:GraphSynth.Representation.hyperarc.IntraArcs">
            <summary>
            Gets the arcs that connect to and from nodes within this hyperarc.
            </summary>
            <value>The intra-connected arcs.</value>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.ConnectTo(GraphSynth.Representation.node)">
            <summary>
            Connects the hyperarc to a new node.
            </summary>
            <param name="newNode">The new node.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.DisconnectFrom(GraphSynth.Representation.node)">
            <summary>
            Disconnects the hyperarc from a node.
            </summary>
            <param name="removeNode">The remove node.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.#ctor(System.String,System.Collections.Generic.IEnumerable{GraphSynth.Representation.node})">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.hyperarc" /> class.
            </summary>
            <param name = "newName">The new name.</param>
            <param name = "attachedNodes">The attached nodes.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.hyperarc" /> class.
            </summary>
            <param name = "newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.hyperarc" /> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.copy">
            <summary>
              Copies this instance of an arc and returns the copy.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.hyperarc.copy(GraphSynth.Representation.hyperarc)">
            <summary>
              Copies this.arc into the argument copyOfArc.
            </summary>
            <param name = "copyOfArc">The copy of arc.</param>
        </member>
        <member name="T:GraphSynth.Representation.node">
            <summary>
              One of the two basic classes for a graph is the node or vertex.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.node._arcs">
            <summary />
        </member>
        <member name="P:GraphSynth.Representation.node.arcs">
            <summary>
              Gets the arcs connected to the node. This includes both arcs and hyperArcs.
            </summary>
            <value>The arcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.arcsTo">
            <summary>
              Gets the arcs entering this node - head (or to) of the
              arc is connected to this node.
            </summary>
            <value>The arcs to.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.arcsFrom">
            <summary>
              Gets the arcs leaving this node - tail (or from) of the
              arc is connected to this node.
            </summary>
            <value>The arcs from.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.X">
            <summary>
              Gets or sets the X coordinate.
            </summary>
            <value>The X coordinate.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.Y">
            <summary>
              Gets or sets the Y coordinate.
            </summary>
            <value>The Y coordinate.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.Z">
            <summary>
              Gets or sets the Z coordinate.
            </summary>
            <value>The Z coordinate.</value>
        </member>
        <member name="P:GraphSynth.Representation.node.degree">
            <summary>
              Gets the degree. The degree or valence of a node is the number of arcs connecting to it.
              Currently this is used in recognition of a rule when the strictDegreeMatch is checked.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="M:GraphSynth.Representation.node.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.node"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.node.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.node" /> class.
            </summary>
            <param name = "newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.node.copy">
            <summary>
              Copies this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.node.copy(GraphSynth.Representation.node)">
            <summary>
              Copies the specified copy of node.
            </summary>
            <param name = "copyOfNode">The copy of node.</param>
        </member>
        <member name="T:GraphSynth.Representation.vertex">
            <summary>
              Originally, I created a separate edge and vertex class to allow for the future expansion
              of GraphSynth into shape grammars. I now have decided that the division is not useful, 
              since it simply deprived nodes of X,Y,Z positions. Many consider edge and arc, and vertex
              and node to be synonymous anyway but I prefer to think of edges and vertices as arcs and 
              nodes with spatial information. At any rate there is no need to have these inherited 
              classes, but I keep them for backwards-compatible purposes.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.vertex.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.vertex" /> class.
            </summary>
            <param name = "name">The name.</param>
        </member>
        <member name="M:GraphSynth.Representation.vertex.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.vertex" /> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.vertex.copy">
            <summary>
              Copies this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Representation.embeddingRule">
            <summary>
              The embedding rule defines what to do with arcs that are freed (one or both of its connecting
              nodes is deleted) by the enclosing grammar rule.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.freeArcLabels">
            <summary>
              The list of labels that the free arc must have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.freeArcNegabels">
            <summary>
              The list of labels that the free arc must NOT have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.neighborNodeLabels">
            <summary>
              The list of labels that the remaining neighboring node 
              must have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.neighborNodeNegabels">
            <summary>
              The list of labels that the remaining neighboring node 
              must NOT have for this embedding rule to be recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.embeddingRule.oldLabels">
            <summary>
              In order to be backwards compatible, this field captures the old fields and converts them
              to proper places. See use in BasicFiler.cs
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.LNodeName">
            <summary>
              Gets or sets the name of the L node that was attached to the 
              free arc. This is NOT the name of the node in the host graph, 
              but in the L of the rule.
            </summary>
            <value>The name of the L node.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.RNodeName">
            <summary>
              Gets or sets the name of the R node to connect this arc to. There is no need to include 
              any other defining character - of course we still need to find the corresponding node 
              in H1 to connect it to. Note, this is also the main quality that distinguishes the 
              approach as NCE or NLC, as the control is given to the each individual of R-L (or the
              daughter graph in the NCE lingo) as opposed to simply a label based method.
            </summary>
            <value>The name of the R node.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.originalDirection">
            <summary>
              Gets or sets the original direction that must be free for this embedding rule to be recognized.
              in order to give the edNCE approach the "ed" quality, we must allow for the possibility of
              recognizing arcs having a particular direction. The original direction can be either +1 meaning
              "to", or -1 meaning "from", or 0 meaning no imposed direction - this indicates what side of the 
              arc is dangling. Furthermore, the newDirection, can specify a new direction of the arc ("to",
              or "from" being the new connection) or "" (unspecified) for updating the arc. This allows us 
              to change the direction of the arc, or keep it as is.
            </summary>
            <value>The original direction.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.newDirection">
            <summary>
              Gets or sets the new direction of the arc. Yes, the arc can actually be flipped by the embedding rule.
            </summary>
            <value>The new direction.</value>
        </member>
        <member name="P:GraphSynth.Representation.embeddingRule.allowArcDuplication">
            <summary>
              Gets or sets a value indicating whether [allow arc duplication].
            </summary>
            <value><c>true</c> if [allow arc duplication]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:GraphSynth.Representation.embeddingRule.arcIsFree(GraphSynth.Representation.arc,GraphSynth.Representation.designGraph,System.SByte@,GraphSynth.Representation.node@)">
            <summary>
              Is the arc a free arc from this grammar rule?
            </summary>
            <param name = "a">A.</param>
            <param name = "host">The host.</param>
            <param name = "freeEndIdentifier">The free end identifier.</param>
            <param name = "neighborNode">The neighbor node.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.embeddingRule.ruleIsRecognized(System.SByte,GraphSynth.Representation.arc,GraphSynth.Representation.node,GraphSynth.Representation.node)">
            <summary>
              Is the rule recognized on the given inputs?
            </summary>
            <param name = "freeEndIdentifier">The free end identifier.</param>
            <param name = "freeArc">The free arc.</param>
            <param name = "neighborNode">The neighbor node.</param>
            <param name = "nodeRemoved">The node removed.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Representation.grammarRule">
            <summary>
            </summary>
            <summary>
            All of these functions are static Booleans functions that match the graph or graph elements between host and rule.
            </summary>
            <summary>
            A partial description of the grammar rule class. In addition to storing designGraphs
            for both the left and right hand sides, there are a variety of functions for describing
            how a rule recognizes on a host, and how it makes changes via apply.
            </summary>
            <summary>
            A partial description of the grammar rule class. In addition to storing designGraphs
            for both the left and right hand sides, there are a variety of functions for describing
            how a rule recognizes on a host, and how it makes changes via apply.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.host">
            <summary>
            the host graph is stored as an internal (private) field to a rule during recognition. 
            Since recognition just reads from it, this simplifies the need to pass it along to every
            recognition function. 
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.DLLofFunctions">
            <summary>
              any mathematical operations are fair game for the recognize and apply local variables.
              At the end of a graph recognition, we check all the recognize functions, if any yield a 
              positive number than the rule is infeasible. This is done in case1LocationFound.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.applyFuncs">
            <summary>
              a list of MethodInfo's corresponding to the strings in applyFunctions
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.globalLabelStartLocs">
            <summary>
              These are place holders when the user has clicked OrderedGlobalLabels. There may, in fact,
              be multiple locations for the globalLabels to be recognized. The are determined in the 
              OrderLabelsMatch function.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.options">
            <summary>
              this is where we store the subgraphs or locations of where the
              rule can be applied. It's global to a particular L but it is invoked
              only at the very bottom of the recursion tree - see the end of
              recognizeRecursion().
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule.recognizeFuncs">
            <summary>
              a list of MethodInfo's corresponding to the strings in recognizeFunctions
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.name">
            <summary>
              Gets or sets the name of the rule.
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.comment">
            <summary>
              Gets or sets a comment about the rule.
            </summary>
            <value>The comment.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.termination">
            <summary>
              Gets or sets a value indicating whether this <see cref = "T:GraphSynth.Representation.grammarRule" /> is termination.
            </summary>
            <value><c>true</c> if termination; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.embeddingRules">
            <summary>
              Gets or sets the embedding rules.
            </summary>
            <value>The embedding rules.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.recognizeFunctions">
            <summary>
              Gets or sets the additional recognize functions names.
            </summary>
            <value>The recognize functions.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.applyFunctions">
            <summary>
              Gets or sets the apply functions.
            </summary>
            <value>The apply functions.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.L">
            <summary>
              Gets or sets  the left-hand-side of the rule. It is a graph that is to be 
              recognized in the host graph.
            </summary>
            <value>The L.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.R">
            <summary>
              Gets or sets the right-hand-side of the rule. It is a graph that is to be 
              inserted (glued) into the host graph.
            </summary>
            <value>The R.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.spanning">
            <summary>
              Gets or sets a value indicating whether this <see cref = "T:GraphSynth.Representation.grammarRule" /> is spanning.
            </summary>
            <value><c>true</c> if spanning; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.induced">
            <summary>
              Gets or sets a value indicating whether this <see cref = "T:GraphSynth.Representation.grammarRule" /> is induced.
            </summary>
            <value><c>true</c> if induced; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.negateLabels">
            <summary>
              Gets or sets the negating labels - labels that must NOT exist in the host.
            </summary>
            <value>The negating labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.containsAllGlobalLabels">
            <summary>
              Gets or sets a value indicating whether the host must contains only the
              global labels of the rule. Said another way, the rule must contain all global labels
              in the host to be a valid match. If false, then a subset of global labels is sufficient.
            </summary>
            <value>
              <c>true</c> if [contains all global labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.OrderedGlobalLabels">
            <summary>
              Gets or sets a value indicating whether the host must contain the
              global labels in the presented order. This is mainly to allow for the creation of traditional
              string grammars.
            </summary>
            <value><c>true</c> if [ordered global labels]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.makeUniqueNodeName(System.String)">
            <summary>
              Makes a unique name of a node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.makeUniqueArcName(System.String)">
            <summary>
              Makes a unique name of an arc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.makeUniqueHyperarcName(System.String)">
            <summary>
              Makes a unique name of a hyperarc.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.arcMatches(GraphSynth.Representation.ruleArc,GraphSynth.Representation.arc,GraphSynth.Representation.node,GraphSynth.Representation.node,System.Boolean)">
            <summary>
            Returns a true/false based on if the host arc matches with this ruleArc.
            </summary>
            <param name="LArc">The L arc.</param>
            <param name="hostArc">The host arc.</param>
            <param name="fromHostNode">From host node.</param>
            <param name="nextHostNode">The next host node.</param>
            <param name="LTraversesForward">if set to <c>true</c> [traverse forward].</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.hasLargerOrEqualDegreeSeqence(System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Determines whether A has larger or equal degree seqence to B.
            </summary>
            <param name="ASequence">The A sequence.</param>
            <param name="BSequence">The B sequence.</param>
            <returns>
              <c>true</c> if  A [has larger or equal degree seqence] [the specified B sequence]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.otherArcsInHost(GraphSynth.Representation.designGraph,GraphSynth.Representation.option)">
            <summary>
            This function is used when checking for an induced subgraph (near line 300 of this file under
            the function case1LocationFound). I have placed it here near the induced property because that's
            a logical place as any in such a big file.
            </summary>
            <param name="host">The host graph.</param>
            <param name="location">The location.</param>
            <returns>
            true - if no other arcs exist between the locatedNodes.
            </returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.HyperArcPreclusionCheckForSingleNode(GraphSynth.Representation.ruleNode,GraphSynth.Representation.node,System.Collections.Generic.IList{GraphSynth.Representation.hyperarc})">
            <summary>
            Hyperarc preclusion check for single node. Actually also "inclusion" check. Checks that host has
            nodes connected in the same way to the hyperarcs as they are in the rule's LHS.
            </summary>
            <param name="LNode">The L node.</param>
            <param name="hostNode">The host node.</param>
            <param name="hostHyperarcs">The host hyperarcs.</param>
            <returns>
            true if preclusions are correct for this node (it is not included
            in hyperarcs it was intentionally precluded from.
            </returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.recognize(GraphSynth.Representation.designGraph,System.Boolean,GraphSynth.Representation.Relaxation)">
            <summary>
            Determines locations where the rule is recognized on the specified host.
            here is the big one! Although it looks fairly short, a lot of time can be spent in
            the recursion that it invokes. Before we get to that, we want to make sure that
            our time there is well spent. As a result, we try to rule out whether the rule
            can even be applied at first -- hence the series of if-thens. If you don't
            meet the first, leave now! likewise for the second. The third is a little trickier.
            if there are no nodes or arcs in this rule, then it has already proven to be valid
            by the global labels - thus return a single location.
            The real work happens in the findNewStartElement which is time-consuming so we first
            do some simply counting to see if the host is bigger than the LHS.
            When findNewStartElement recurses down and divides, a number of options may be created
            in the final method (LocationFound). If there are multiple locations within the
            global labels then we merge the two together.
            </summary>
            <param name="host">The host.</param>
            <param name="InParallel">if set to <c>true</c> [in parallel].</param>
            <param name="RelaxationTemplate">The relaxation template.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.apply(GraphSynth.Representation.designGraph,GraphSynth.Representation.option,System.Double[])">
            <summary>
              Applies the rule to the specified host.
            </summary>
            <param name = "host">The host.</param>
            <param name = "Lmapping">The lmapping.</param>
            <param name = "parameters">The parameters.</param>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.updateAdditionalFunctions(GraphSynth.Representation.option,GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph,System.Collections.IEnumerable)">
            <summary>
              The final update step is to invoke additional functions for the rule. 
              These are traditionally called the Parametric Application Functions, but
              they can do any custom modifications to the host.
            </summary>
            <param name = "Lmapping">The lmapping.</param>
            <param name = "host">The host.</param>
            <param name = "Rmapping">The rmapping.</param>
            <param name = "parameters">The parameters.</param>
        </member>
        <member name="F:GraphSynth.Representation.grammarRule._regularizationMatrix">
            <summary>
              this matrix determines the transform to place the first node at (0,0) and the 
              second node at (r,0). This is not stored in the file since it can be quickly 
              determined.
            </summary>                                
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.ResetRegularizationMatrix">
            <summary>
              Resets the regularization matrix.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.calculateRegularizationMatrix">
            <summary>
            Calculates the regularization matrix. This is a matrix that is used to simplify the 
            shape recognition process. Multiplying the LHS by R (the regularization matrix), the
            first node will now be at {0,0,0}, the second is on the x-axis {d1, 0, 0}, then third
            is on the x-y plane {d2, d3, 0}. This simplifies the calculations in finding the transformation
            of the LHS to get it to match the host shape.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.UseShapeRestrictions">
            <summary>
              Gets or sets a value indicating whether [use shape restrictions].
            </summary>
            <value>
              <c>true</c> if [use shape restrictions]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.RestrictToNodeShapeMatch">
            <summary>
            Gets or sets a value indicating whether [restrict to node shape match].
            </summary>
            <value>
            	<c>true</c> if [restrict to node shape match]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.TransformNodePositions">
            <summary>
            Gets or sets a value indicating whether [transform node positions].
            </summary>
            <value><c>true</c> if [transform node positions]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.TransformNodeShapes">
            <summary>
            Gets or sets a value indicating whether the node shapes are also transformed or simply their position.
            </summary>
            <value><c>true</c> if [transform node shapes]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Translate">
            <summary>
              Gets or sets the translate transformation allowance.
            </summary>
            <value>The translate.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Scale">
            <summary>
              Gets or sets the scale transformation allowance.
            </summary>
            <value>The scale.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Skew">
            <summary>
              Gets or sets the skew transformation allowance.
            </summary>
            <value>The skew.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Flip">
            <summary>
              Gets or sets the flip transformation allowance.
            </summary>
            <value>The flip.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Rotate">
            <summary>
              Gets or sets a value indicating whether this <see cref = "T:GraphSynth.Representation.grammarRule" /> allows a rotation transformation.
            </summary>
            <value><c>true</c> if rotate; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.grammarRule.Projection">
            <summary>
              Gets or sets the projection transformation allowance.
            </summary>
            <value>The projection.</value>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.ReorderNodes">
            <summary>
            Reorders the nodes for best shape transform. This is to put all NOT-exist nodes
            at the end of the list and to avoid unlikely problems when first 3 or 4 nodes 
            are collinear or sitting on top of each other.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.TransformPositionOfNode(GraphSynth.Representation.node,System.Double[0:,0:],GraphSynth.Representation.node)">
            <summary>
              Updates the position of a node.
            </summary>
            <param name = "update">The node to update.</param>
            <param name = "T">The Transformation matrix, T.</param>
            <param name = "given">The given rule node.</param>
        </member>
        <member name="M:GraphSynth.Representation.grammarRule.TransfromShapeOfNode(GraphSynth.Representation.node,System.Double[0:,0:])">
            <summary>
            Transfroms the shape of node.
            </summary>
            <param name="update">The update.</param>
            <param name="T">The T.</param>
        </member>
        <member name="T:GraphSynth.Representation.option">
            <summary>
              A rule is not enough - the Opion class captures all the details of
              an decision option from one point in the search process. The list of
              options are presented in the choice for which rule to apply. Option 
              contains references to the location where the rule is applicable, 
              the rule itself, along with its number in the ruleSet and the ruleSet's
              number when there are multiple ruleSets.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.option.parameters">
            <summary>
              A list of parameters chosen and used by the apply fuctions of the rule.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.option._arcs">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.option._hyperarcs">
            <summary />
        </member>
        <member name="F:GraphSynth.Representation.option._nodes">
            <summary />
        </member>
        <member name="P:GraphSynth.Representation.option.arcs">
            <summary>
              Gets or sets the arcs.
            </summary>
            <value>The arcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.nodes">
            <summary>
              Gets the nodes.
            </summary>
            <value>The nodes.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.hyperarcs">
            <summary>
              Gets the hyperarcs.
            </summary>
            <value>The hyperarcs.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.optionNumber">
            <summary>
              Gets or sets the option number.
            </summary>
            <value>The option number.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.ruleSetIndex">
            <summary>
              Gets or sets the index of the rule set.
            </summary>
            <value>The index of the rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.ruleNumber">
            <summary>
              Gets or sets the rule number.
            </summary>
            <value>The rule number.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.rule">
            <summary>
              Gets or sets the rule.
            </summary>
            <value>The rule.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.globalLabelStartLoc">
            <summary>
              Gets or sets the global label start loc.
            </summary>
            <value>The global label start loc.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.positionTransform">
            <summary>
              Gets or sets the position transform.
            </summary>
            <value>The position transform.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.confluence">
            <summary>
              Gets or sets the confluence.
            </summary>
            <value>The confluence.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.probability">
            <summary>
              Gets or sets the probability.
            </summary>
            <value>The probability.</value>
        </member>
        <member name="P:GraphSynth.Representation.option.Relaxations">
            <summary>
            Gets or sets the relaxations.
            </summary>
            <value>
            The relaxations.
            </value>
        </member>
        <member name="M:GraphSynth.Representation.option.#ctor(GraphSynth.Representation.grammarRule)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.option"/> class.
            </summary>
            <param name="rule">The rule.</param>
        </member>
        <member name="M:GraphSynth.Representation.option.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.option"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.option.apply(GraphSynth.Representation.designGraph,System.Double[])">
            <summary>
              Applies the option to the specified host. It is essentially
              a shorthand instead of calling 
              option.rule.apply(option.location, host, parameters); we call
              option.apply(host, parameters).
            </summary>
            <param name = "host">The host.</param>
            <param name = "Parameters">The parameters.</param>
        </member>
        <member name="M:GraphSynth.Representation.option.copy">
            <summary>
              Returns a copy of this instance of option. Note that location is a 
              shallow copy and applies to the same host.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.findLMappedElement(System.String)">
            <summary>
            Finds the L mapped element.
            </summary>
            <param name="GraphElementName">Name of the graph element.</param>
            <returns></returns>
            <exception cref="T:System.Exception">Graph element named \ + GraphElementName + \ was not found in the L-mapping of rule  + GraphElementName</exception>
        </member>
        <member name="M:GraphSynth.Representation.option.findLMappedElement(GraphSynth.Representation.graphElement)">
            <summary>
            Finds the L mapped element.
            </summary>
            <param name="x">The x.</param>
            <returns></returns>
            <exception cref="T:System.Exception">Graph element not found in rule's left-hand-side (GrammarRule.findMappedElement)</exception>
        </member>
        <member name="M:GraphSynth.Representation.option.findLMappedNode(GraphSynth.Representation.node)">
            <summary>
            Finds the L mapped node.
            </summary>
            <param name="x">The x.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.findLMappedArc(GraphSynth.Representation.arc)">
            <summary>
            Finds the L mapped arc.
            </summary>
            <param name="x">The x.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.findLMappedHyperarc(GraphSynth.Representation.hyperarc)">
            <summary>
            Finds the L mapped hyperarc.
            </summary>
            <param name="x">The x.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.AssignOptionConfluence(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate,GraphSynth.ConfluenceAnalysis)">
            <summary>
            Create lists on integers within each option that indicates what other
            options in that list it is confluent with. As discussed below confluence
            is commutative which saves a little time in this function, but it is not
            transitive - meaning is A is confluent with B and C. It is not necessarily
            true that B is confluent with C.
            </summary>
            <param name="options">The list of options to assign confluence</param>
            <param name="cand">The cand.</param>
            <param name="confluenceAnalysis">The confluence analysis.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.MakeInvalidationMatrix(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate,GraphSynth.ConfluenceAnalysis)">
            <summary>
            Makes the invalidation matrix.
            a -1 means that the row option does NOT violate the column option
            a 0 means Maybe - this happens when the ConfluenceAnalysis is not set to Full and rules have additional functions
            a +1 means that the row option DOES invalide the column option
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
            <param name="confluenceAnalysis">The confluence analysis.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.doesPInvalidateQ(GraphSynth.Representation.option,GraphSynth.Representation.option,GraphSynth.Representation.candidate,GraphSynth.ConfluenceAnalysis)">
            <summary>
            Predicts whether the option p  invalidates option q.
            This invalidation is a tricky thing. For the most part, this function
            has been carefully coded to handle all cases. The only exceptions
            are from what the additional recognize and apply functions require or modify.
            This is handled by actually testing to see if this is true.
            </summary>
            <param name="p">The p.</param>
            <param name="q">The q.</param>
            <param name="cand">The cand.</param>
            <param name="confluenceAnalysis">The confluence analysis.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.fullInvalidationCheck(GraphSynth.Representation.option,GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
            Does a full invalidation check through empirical evidence. That is, it makes
            a copy of the graph and tests to see if this is true.
            </summary>
            <param name="p">The p.</param>
            <param name="q">The q.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.option.sameLocation(GraphSynth.Representation.option,GraphSynth.Representation.option)">
            <summary>
            Sames the location.
            </summary>
            <param name="qOption">The q option.</param>
            <param name="newOption">The new option.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Representation.Relaxation">
            <summary>
            
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.Relaxation.#ctor(System.Collections.Generic.List{GraphSynth.Representation.RelaxItem},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.Relaxation"/> class.
            </summary>
            <param name="prescribedItems">The prescribed items.</param>
            <param name="NumberAllowable">The number allowable.</param>
        </member>
        <member name="M:GraphSynth.Representation.Relaxation.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.Relaxation"/> class.
            </summary>
            <param name="NumberAllowable">The number allowable.</param>
        </member>
        <member name="P:GraphSynth.Representation.Relaxation.InitialAllowableRelaxes">
            <summary>
            Gets the allowable relaxes.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.Relaxation.NumberAllowable">
            <summary>
            Gets the number allowable relaxations that are left (not initially prescribed).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxation.items">
            <summary>
            The prescribed relaxation items.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.Relaxation.FulfilledItems">
            <summary>
            Gets the fulfilled items.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.Relaxation.RelaxationSummary">
            <summary>
            Gets the summary of relaxation that were used to make the match.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.Relaxation.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:GraphSynth.Representation.Relaxation.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:GraphSynth.Representation.Relaxation.copy">
            <summary>
            Copies this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.Relaxation.Reset">
            <summary>
            Resets the relaxation back to the way it was originally defined.
            </summary>
        </member>
        <member name="T:GraphSynth.Representation.RelaxItem">
            <summary>
            The RelaxItem describes the manner in which one can relax a rule or ruleset.
            A list of these is defined for the Relaxation class.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.RelaxItem.GraphElement">
            <summary>
            Gets the elt.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.RelaxItem.RelaxationType">
            <summary>
            Gets the type of the relaxation.
            </summary>
            <value>
            The type of the relaxation.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.RelaxItem.Datum">
            <summary>
            Gets the datum.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.RelaxItem.AppliesTo">
            <summary>
            Gets the applies to.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.RelaxItem.NumberAllowed">
            <summary>
            Gets or sets the number of relaxations of this type that are allowed.
            </summary>
            <value>
            The number allowed.
            </value>
        </member>
        <member name="M:GraphSynth.Representation.RelaxItem.#ctor(GraphSynth.Representation.Relaxations,System.Int32,GraphSynth.Representation.graphElement,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.RelaxItem"/> class.
            </summary>
            <param name="RelaxationType">Type of the relaxation.</param>
            <param name="NumberAllowed">The number allowed.</param>
            <param name="GraphElement">The graph element.</param>
            <param name="Datum">The datum.</param>
        </member>
        <member name="T:GraphSynth.Representation.Relaxations">
            <summary>
            The enumerator of the Relaxation Types
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Any">
            <summary>
            Any is a wildcard for any of the following specific types of relaxations
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Contains_All_Global_Labels_Revoked">
            <summary>
            the contains all global labels condition is revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Ordered_Global_Labels_Revoked">
            <summary>
            the ordered global labels condition is revoked 
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Global_Label_Revoked">
            <summary>
            a global label as indicated by |DATUM| is revoked.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Negate_Global_Label_Revoked">
            <summary>
            a global negating label as indicated by |DATUM| is revoked.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Spanning_Revoked">
            <summary>
            the spanning restriction is revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Additional_Functions_Revoked">
            <summary>
            A particular additional functions as indicated by |DATUM| is revoked.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Shape_Restriction_Revoked">
            <summary>
            all shape restrictions are revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Induced_Revoked">
            <summary>
            the induced condition is revoked (set to false)
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Contains_All_Local_Labels_Revoked">
            <summary>
            the contains all local labels condition of the |GraphElement| is revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Contains_All_Local_Labels_Imposed">
            <summary>
            the contains all local labels condition of the |GraphElement| is imposed 
            to prevent a match for negative (NOT_EXIST) elements.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Contains_All_Local_Labels_Altered">
            <summary>
            the contains all local labels condition of the |GraphElement| can be
            either revoked (for positivie elements) or imposed (for negative elements).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Label_Revoked">
            <summary>
            a label of the |GraphElement| as named in |DATUM| is revoked.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Label_Imposed">
            <summary>
            a label of the |GraphElement| as named in |DATUM| is imposed 
            to prevent a match for negative (NOT_EXIST) elements. 
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Label_Altered">
            <summary>
            a label of the |GraphElement| as named in |DATUM| can be
            either revoked (for positivie elements) or imposed (for negative elements).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Negate_Label_Revoked">
            <summary>
            the negating label of the |GraphElement| as named in |DATUM| is revoked.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Negate_Label_Imposed">
            <summary>
            the negating label of the |GraphElement| as named in |DATUM| is imposed 
            to prevent a match for negative (NOT_EXIST) elements.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Negate_Label_Altered">
            <summary>
            the negating label of the |GraphElement| as named in |DATUM| can be
            either revoked (for positivie elements) or imposed (for negative elements).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Null_Means_Null_Revoked">
            <summary>
            the NullMeansNull condition of the arc indicated by |GraphElement| is revoked
            (treated as false).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Null_Means_Null_Imposed">
            <summary> 
            the NullMeansNull condition of the arc indicated by |GraphElement| is imposed 
            (set as true) to prevent a match for negative (NOT_EXIST) elements.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Null_Means_Null_Altered">
            <summary>
            the NullMeansNull condition of the arc indicated by |GraphElement| can be
            either revoked (for positivie elements) or imposed (for negative elements).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Direction_Is_Equal_Revoked">
            <summary>
            the DirectionIsEqual condition of the arc indicated by |GraphElement| is revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Direction_Is_Equal_Imposed">
            <summary>
            the DirectionIsEqual condition of the arc indicated by |GraphElement| is imposed 
            to prevent a match for negative (NOT_EXIST) elements.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Direction_Is_Equal_Altered">
            <summary>
            the DirectionIsEqual condition of the arc indicated by |GraphElement| can be
            either revoked (for positivie elements) or imposed (for negative elements).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Strict_Degree_Match_Revoked">
            <summary>
            Strict Degree Match of the node indicated by |GraphElement| is revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Strict_Degree_Match_Imposed">
            <summary>
            Strict Degree Match of the node indicated by |GraphElement| is imposed 
            to prevent a match for negative (NOT_EXIST) elements.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Strict_Degree_Match_Altered">
            <summary>
            Strict Degree Match of the node indicated by |GraphElement| can be
            either revoked (for positivie elements) or imposed (for negative elements).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Strict_Node_Count_Revoked">
            <summary>
            Strict Node Count of the hyperarc indicated by |GraphElement| is revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Strict_Node_Count_Imposed">
            <summary>
            Strict Node Count of the hyperarc indicated by |GraphElement| is imposed 
            to prevent a match for negative (NOT_EXIST) elements.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Strict_Node_Count_Altered">
            <summary>
            Strict Node Count of the hyperarc indicated by |GraphElement| can be
            either revoked (for positivie elements) or imposed (for negative elements).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.HyperArc_Preclusion_Revoked">
            <summary>
            hyperarc preclusion is revoked, meaning that a node actually
            connects to a hyperarc (as indicated by |DATUM|) in L (even 
            though L shows them disconnected).
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Target_Type_Revoked">
            <summary>
            the target type of the |GraphElement| is revoked
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Element_Made_Positive">
            <summary>
            the NOTEXIST condition of |GraphElement| is revoked, but it must be found
            as if a positive element.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.Relaxations.Element_Made_Negative">
            <summary>
            the element as indicated by |GraphElement| is removed from L
            </summary>
        </member>
        <member name="T:GraphSynth.Representation.ruleArc">
            <summary>
              The ruleArc class is an inherited class from arc which includes additional details
              necessary to correctly perform recognition. This mostly hinges on the "subset or equal"
              Booleans.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.ruleArc" /> class with a particular name.
            </summary>
            <param name = "newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.ruleArc" /> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.#ctor(GraphSynth.Representation.arc)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleArc"/> class.
              Converts an arc to a ruleArc and returns it with default Booleans.
              The original arc is unaffected.
            </summary>
            <param name="a">A.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleArc.copy(GraphSynth.Representation.arc)">
            <summary>
              Copies this instance into the (already intialized) copyOfArc.
            </summary>
            <param name = "copyOfArc">A new copy of arc.</param>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.negateLabels">
            <summary>
              Gets the negating labels. The labels that must not exist for correct recognition.
            </summary>
            <value>The negate labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.NotExist">
            <summary>
            Gets or sets a value indicating whether the element should not exist in the
            host graph.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.MustExist">
            <summary>
            Gets the value indicating whether the element SHOULD exist in the
            host graph. It is just the opposite (true/false) or NotExist.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.containsAllLocalLabels">
            <summary>
              Gets or sets a value indicating whether arc must contain all the local labels of the matching element.
            </summary>
            <value>
              <c>true</c> if [contains all local labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.TargetType">
            <summary>
              Gets or sets the type (as a string) for the matching graph element.
            </summary>
            <value>The string describing the type of graph element.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.directionIsEqual">
            <summary>
              Gets or sets a value indicating whether the directionality within the arc is to match
              perfectly. If false then all (singly)-directed arcs
              will match with doubly-directed arcs, and all undirected arcs will match with all
              directed and doubly-directed arcs. Of course, a directed arc going one way will 
              still not match with a directed arc going the other way.
              If true, then undirected only matches with undirected, directed only with directed (again, the
              actual direction must match too), and doubly-directed only with doubly-directed.
            </summary>
            <value><c>true</c> if [direction is equal]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleArc.nullMeansNull">
            <summary>
              Gets or sets a value indicating whether dangling (the null reference to node) arc are only
              to match with dangling arcs.If this is set to false, then we are saying a 
              null reference on an arc can be matched with a null in the graph or any node in the graph. 
              Like the above, a false value is like a subset in that null is a subset of any actual node. 
              And a true value means it must match exactly or in otherwords, "null means null" - null 
              matches only with a null in the host. If you want the rule to be recognized only when an actual
              node is present simply add a dummy node with no distinguishing characteristics. That would
              in turn nullify this boolean since this boolean only applies when a null pointer exists in
              the rule.
            </summary>
            <value><c>true</c> if [null means null]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:GraphSynth.Representation.ruleHyperarc">
            <summary>
              The ruleHyperArc class is an inherited class from hyperarc which includes additional details
              necessary to correctly perform recognition. This mostly hinges on the "subset or equal"
              Booleans.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.ruleHyperarc" /> class.
            </summary>
            <param name = "newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.ruleHyperarc" /> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.#ctor(GraphSynth.Representation.hyperarc)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleHyperarc"/> class.
            Converts a hyperarc to a ruleHyperArc and returns it with default Booleans.
            The original hyperarc is unaffected.
            </summary>
            <param name="ha">The hyperarc, ha.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns>the copy of the arc.</returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleHyperarc.copy(GraphSynth.Representation.hyperarc)">
            <summary>
              Copies this instance into the (already intialized) copyOfHyperArc.
            </summary>
            <param name = "copyOfHyperArc">The copy of node.</param>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.negateLabels">
            <summary>
              Gets the negating labels. The labels that must not exist for correct recognition.
            </summary>
            <value>The negate labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.NotExist">
            <summary>
            Gets or sets a value indicating whether the element should not exist in the
            host graph.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.MustExist">
            <summary>
            Gets the value indicating whether the element SHOULD exist in the
            host graph. It is just the opposite (true/false) or NotExist.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.containsAllLocalLabels">
            <summary>
              Gets or sets a value indicating whether arc must contain all the local labels of the matching element.
            </summary>
            <value>
              <c>true</c> if [contains all local labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.TargetType">
            <summary>
              Gets or sets the type (as a string) for the matching graph element.
            </summary>
            <value>The string describing the type of graph element.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.strictNodeCountMatch">
            <summary>
            Gets or sets a value indicating whether [strict node count match].
            </summary>
            <value>
            	<c>true</c> if [strict node count match]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleHyperarc.degree">
            <summary>
            Gets the degree of the hyperarcs - the number of nodes that it connects to.
             A slight difference exists for ruleNode since we don't want to count "NotExist" arcs.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="T:GraphSynth.Representation.ruleNode">
            <summary>
              The ruleNode class is an inherited class from node which includes additional details
              necessary to correctly perform recognition. This mostly hinges on the "subset or equal"
              Booleans.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.ruleNode" /> class with a particular name.
            </summary>
            <param name = "newName">The new name.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.ruleNode" /> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.#ctor(GraphSynth.Representation.node)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleNode"/> class.
            Up-casts the node to a ruleNode and returns it with default Booleans.
            The original node is unaffected.
            </summary>
            <param name="n">The node.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleNode.copy(GraphSynth.Representation.node)">
            <summary>
              Copies this instance into the (already intialized) copyOfNode.
            </summary>
            <param name = "copyOfNode">A new copy of node.</param>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.negateLabels">
            <summary>
              Gets the negating labels. The labels that must not exist for correct recognition.
            </summary>
            <value>The negate labels.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.NotExist">
            <summary>
            Gets or sets a value indicating whether the element should not exist in the
            host graph.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.MustExist">
            <summary>
            Gets the value indicating whether the element SHOULD exist in the
            host graph. It is just the opposite (true/false) or NotExist.
            </summary>
            <value><c>true</c> if [not exist]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.containsAllLocalLabels">
            <summary>
              Gets or sets a value indicating whether arc must contain all the local labels of the matching element.
            </summary>
            <value>
              <c>true</c> if [contains all local labels]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.TargetType">
            <summary>
              Gets or sets the type (as a string) for the matching graph element.
            </summary>
            <value>The string describing the type of graph element.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.strictDegreeMatch">
            <summary>
              Gets or sets a value indicating whether [strict degree match] is required for recognition.
            </summary>
            <value><c>true</c> if [strict degree match]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleNode.degree">
            <summary>
            Gets the degree. The degree or valence of a node is the number of arcs connecting to it.
            Currently this is used in recognition of a rule when the strictDegreeMatch is checked.
            A slight difference exists for ruleNode since we don't want to count "NotExist" arcs.
            </summary>
            <value>The degree.</value>
        </member>
        <member name="T:GraphSynth.Representation.ruleSet">
            <summary>
              The ruleset class represents one of the three main file types of GraphSynth. A ruleset is saved as a .rsxml. It represents a
              language of rules that operate in concert. The included rules are all loaded at once, and used to populate a list of
              options which make changes to a host.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:GraphSynth.Representation.ruleSet.nextGenerationStep" -->
        <member name="F:GraphSynth.Representation.ruleSet.ruleFileNames">
            <summary>
              Represents a list of the rule file names.
            </summary>
        </member>
        <member name="F:GraphSynth.Representation.ruleSet.rules">
            <summary>
              Represents a list of the rules included within the ruleset.
              The rules are clearly part of the set, but these are not stored
              in the rsxml file, only the ruleFileNames.
            </summary>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.name">
            <summary>
              Gets or sets the name for the ruleSet - usually set to the filename
            </summary>
            <value>The name.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.TriggerRuleNum">
            <summary>
              Gets or sets the trigger rule num. Note: the rule numbers start at 1
              not zero. Here we keep track by using a zero-based private field with
              this property (as a way to remember. I know it sounds strange, but it
              works).
            </summary>
            <value>The trigger rule num.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.choiceMethod">
            <summary>
              Gets or sets the choice method - either automatic or by design.
            </summary>
            <value>The choice method.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.interimCandidates">
            <summary>
              Gets or sets the feasibility state of the interim candidates.
            </summary>
            <value>The interim candidates.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.finalCandidates">
            <summary>
              Gets or sets the feasibility state of the final candidates.
            </summary>
            <value>The final candidates.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.RuleSetIndex">
            <summary>
              Gets or sets the index of the rule set.
            </summary>
            <value>The index of the rule set.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.recognizeSourceFiles">
            <summary>
              Gets or sets the recognize source file names (string paths).
            </summary>
            <value>The recognize source files.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.applySourceFiles">
            <summary>
              Gets or sets the apply source file names (string paths).
            </summary>
            <value>The apply source files.</value>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.nextRuleSet(GraphSynth.GenerationStatuses)">
            <summary>
              Retrieves the index of the next rule set.A helper function to RecognizeChooseApplyCycle.
              This function returns what the new ruleSet will be. Here the enumerator nextGenerationSteps
              and GenerationStatuses is used to great affect. Understand that if a negative number is
              returned, the cycle will be stopped.
            </summary>
            <param name = "status">The status.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Representation.ruleSet" /> class.
            </summary>
            <param name = "defaultRulesDir">The default rules dir.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Representation.ruleSet"/> class.
            </summary>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.recognize(GraphSynth.Representation.designGraph,System.Boolean,GraphSynth.Representation.Relaxation)">
            <summary>
            This is the recognize function called within the RCA generation. It is
            fairly straightforward method that basically invokes the more complex
            recognize function for each rule within it, and returns a list of
            options.
            </summary>
            <param name="host">The host.</param>
            <param name="InParallel">if set to <c>true</c> [in parallel].</param>
            <param name="RelaxationTemplate">The relaxation template.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.Add(GraphSynth.Representation.grammarRule)">
            <summary>
              Adds the specified new rule.
            </summary>
            <param name = "newRule">The new rule.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.Remove(GraphSynth.Representation.grammarRule)">
            <summary>
              Removes the specified remove rule.
            </summary>
            <param name = "removeRule">The remove rule.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.copy">
            <summary>
              Returns a copy of this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.filer">
            <summary>
              Gets or sets the filer.
            </summary>
            <value>The filer.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.rulesDir">
            <summary>
              Gets or sets the rules dir.
            </summary>
            <value>The rules dir.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterNormal">
            <summary>
              Gets or sets the generation method after normal.
            </summary>
            <value>The generation after normal.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterChoice">
            <summary>
              Gets or sets the generation method after choice.
            </summary>
            <value>The generation after choice.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterCycleLimit">
            <summary>
              Gets or sets the generation method after cycle limit.
            </summary>
            <value>The generation after cycle limit.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterNoRules">
            <summary>
              Gets or sets the generation method after no rules.
            </summary>
            <value>The generation after no rules.</value>
        </member>
        <member name="P:GraphSynth.Representation.ruleSet.generationAfterTriggerRule">
            <summary>
              Gets or sets the generation method after trigger rule.
            </summary>
            <value>The generation after trigger rule.</value>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.loadAndCompileSourceFiles(GraphSynth.Representation.ruleSet[],System.Boolean,System.String,System.String)">
            <summary>
              Loads and compiles the source files.
            </summary>
            <param name = "rulesets">The rulesets.</param>
            <param name = "recompileRules">if set to <c>true</c> [recompile rules].</param>
            <param name = "compiledparamRules">The compiledparam rules.</param>
            <param name = "execDir">The exec dir.</param>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.FindSourceFiles(GraphSynth.Representation.ruleSet[],System.Collections.Generic.List{System.String},System.String)">
            <summary>
              Finds the source files.
            </summary>
            <param name = "rulesets">The rulesets.</param>
            <param name = "allSourceFiles">All source files.</param>
            <param name = "rulesDirectory">The rules directory.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Representation.ruleSet.CompileSourceFiles(GraphSynth.Representation.ruleSet[],System.Collections.Generic.List{System.String},System.CodeDom.Compiler.CompilerResults@,System.String,System.String,System.String)">
            <summary>
              Compiles the source files.
            </summary>
            <param name = "rulesets">The rulesets.</param>
            <param name = "allSourceFiles">All source files.</param>
            <param name = "cr">The cr.</param>
            <param name = "rulesDir">The rules dir.</param>
            <param name = "execDir">The exec dir.</param>
            <param name = "compiledparamRules">The compiledparam rules.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.IntCollectionConverter">
            <summary>
              A converter class for changing a collection of ints into a string and vice-versa.
            </summary>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.Convert(System.String)">
            <summary>
              Converts the for a string of comma-separated-values to a IEnumerable of ints.
            </summary>
            <param name = "value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.IntCollectionConverter.Convert(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
              Converts the specified values from a IEnumerable of ints to a comma-separated string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.DoubleCollectionConverter">
            <summary>
              A converter class for changing a collection of doubles into a string and vice-versa.
            </summary>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.Convert(System.String)">
            <summary>
              Converts the for a string of comma-separated-values to a IEnumerable of doubles.
            </summary>
            <param name = "value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.DoubleCollectionConverter.Convert(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
              Converts the specified values from a IEnumerable of doubles to a comma-separated string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.StringCollectionConverter">
            <summary>
              Used to convert a single string into a list of strings and vice-versa.
            </summary>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.Convert(System.String)">
            <summary>
              Converts the comma-separated-values into a IEnumerable of strings.
            </summary>
            <param name = "value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.StringCollectionConverter.Convert(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
              Converts the specified IEnumerable of strings into a comma separated single string.
            </summary>
            <param name = "values">The values.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.ErrorLogger">
            <summary>
              A class that allows us to dump errors to a txt file in the executable directory.
            </summary>
        </member>
        <member name="F:GraphSynth.ErrorLogger.ErrorLogFile">
            <summary>
              The contents of the Error log
            </summary>
        </member>
        <member name="M:GraphSynth.ErrorLogger.Catch(System.Exception)">
            <summary>
              Catches the specified exception.
            </summary>
            <param name = "Exc">The exc.</param>
        </member>
        <member name="M:GraphSynth.ErrorLogger.MakeErrorString(System.Exception,System.Boolean)">
            <summary>
              Makes the error string.
            </summary>
            <param name = "Exc">The exc.</param>
            <param name = "includeComputerData">if set to <c>true</c> [include computer data].</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.GlobalSettings">
            <summary>
            The Global Settings class loads the the .gsconfig file into an object which 
            is accessed throughout the system.
            </summary>
        </member>
        <member name="M:GraphSynth.GlobalSettings.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.GlobalSettings"/> class.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.ExecDir">
            <summary>
              The directory that GraphSynth.exe is located in
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.ConfigDir">
            <summary>
            Gets or sets the directory where the configuration file was found.
            </summary>
            <value>The config dir.</value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.FilePath">
            <summary>
              Gets or sets the location of the settings file.
            </summary>
            <value>The location.</value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.filer">
            <summary>
            Gets or sets the filer instance that controls the opening and saving of files.
            </summary>
            <value>
            The filer.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.seed">
            <summary>
            Gets or sets the seed graph - although this dll doesn't know what
            a graph is, so you need to "cast up" to really use it.
            </summary>
            <value>
            The seed.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.rulesets">
            <summary>
            Gets or sets the rulesets - although this dll doesn't know what
            a graph is, so you need to "cast up" to really use it.
            </summary>
            <value>
            The rulesets.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.numOfRuleSets">
            <summary>
            Gets or sets the number of rule sets.
            </summary>
            <value>
            The number of rule sets.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.MaxRulesToDisplay">
            <summary>
            Gets or sets the maximum rules to display in GUI driven User Choose.
            </summary>
            <value>
            The max rules to display.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.MaxRulesToApply">
            <summary>
            Gets or sets the max rules to apply.
            </summary>
            <value>
            The max rules to apply.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.WorkingDirAbsolute">
            <summary>
            Gets or sets the absolute working directory.
            </summary>
            <value>
            The absolute working directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.WorkingDirRelative">
            <summary>
            Gets or sets the relative working directory.
            </summary>
            <value>
            The relative working directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.InputDir">
            <summary>
            Gets or sets the input directory.
            </summary>
            <value>
            The input dir.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.InputDirAbs">
            <summary>
            Gets the absolute (rooted) input directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.OutputDir">
            <summary>
            Gets or sets the output directory.
            </summary>
            <value>
            The output dir.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.OutputDirAbs">
            <summary>
            Gets the absolute (rooted) output directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.RulesDir">
            <summary>
            Gets or sets the rules directory.
            </summary>
            <value>
            The rules directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.RulesDirAbs">
            <summary>
            Gets the absolute (rooted) rules directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.LocalHelpDir">
            <summary>
            Gets or sets the local help dir.
            </summary>
            <value>
            The local help dir.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.OnlineHelpURL">
            <summary>
            Gets or sets the online help URL.
            </summary>
            <value>
            The online help URL.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.GraphLayoutDir">
            <summary>
            Gets or sets the graph layout directory.
            </summary>
            <value>
            The graph layout directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.GraphLayoutDirAbs">
            <summary>
            Gets the absolute (rooted) graph layout directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.SearchDir">
            <summary>
            Gets or sets the search directory.
            </summary>
            <value>
            The search directory.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.SearchDirAbs">
            <summary>
            Gets the absolute (rooted) search directory.
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.ErrorLogFile">
            <summary>
            Gets or sets the error log file.
            </summary>
            <value>
            The error log file.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.DefaultSeedFileName">
            <summary>
            Gets or sets the default name of the seed file.
            </summary>
            <value>
            The default name of the seed file.
            </value>
        </member>
        <member name="F:GraphSynth.GlobalSettings.defaultRSFileNames">
            <summary>
            the default ruleset filenames relative to the rules directory
            </summary>
        </member>
        <member name="P:GraphSynth.GlobalSettings.DefaultRuleSets">
            <summary>
            Gets or sets the default rule sets filename as a single string.
            </summary>
            <value>
            The default rule sets.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.CustomShapesFile">
            <summary>
            Gets or sets the custom shapes file.
            </summary>
            <value>
            The custom shapes file.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.CompiledRuleFunctions">
            <summary>
            Gets or sets the compiled param rules.
            </summary>
            <value>
            The compiledparam rules.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.SearchControllerPlayOnStart">
            <summary>
            Gets or sets a value indicating whether search controllers should automatically start playing
            when they are initiated.
            </summary>
            <value>
            	<c>true</c> if [search controller is set to auto-play]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.GetHelpFromOnline">
            <summary>
            Gets or sets a value indicating whether [get help from online].
            </summary>
            <value>
              <c>true</c> if [get help from online]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.RecompileRuleConditions">
            <summary>
            Gets or sets a value indicating whether [recompile rule conditions].
            </summary>
            <value>
            	<c>true</c> if [recompile rule conditions]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:GraphSynth.GlobalSettings.DefaultVerbosity">
            <summary>
            Gets or sets the default verbosity.
            </summary>
            <value>
            The default verbosity.
            </value>
        </member>
        <member name="M:GraphSynth.GlobalSettings.readInSettings(System.String)">
            <summary>
            Reads in the settings.
            </summary>
            <param name="configPath">The file path.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.GlobalSettings.saveNewSettings(System.String)">
            <summary>
            Saves the new settings.
            </summary>
            <param name="filename">The filename.</param>
        </member>
        <member name="M:GraphSynth.GlobalSettings.LoadDefaultSeedAndRuleSets">
            <summary>
            Loads the default seed and rule sets.
            </summary>
        </member>
        <member name="M:GraphSynth.GlobalSettings.Duplicate">
            <summary>
            Copies the exisiting and returns it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.GlobalSettings.LoadDefaults">
            <summary>
            Loads the defaults.
            </summary>
        </member>
        <member name="M:GraphSynth.GlobalSettings.AttemptSubDirMigration(System.String)">
            <summary>
            Attempts to migrate all sub-directories when the working directory is changed.
            Currently this only occurs in the GUI when a working directory has been changed.
            </summary>
        </member>
        <member name="T:GraphSynth.IMainWindow">
            <summary>
            Interface for the main window of GraphSynth.
            </summary>
        </member>
        <member name="P:GraphSynth.IMainWindow.SelectedAddItem">
            <summary>
            Gets the selected add item.
            </summary>
            <value>The selected add item.</value>
        </member>
        <member name="M:GraphSynth.IMainWindow.SetSelectedAddItem(System.Int32)">
            <summary>
            Sets the selected add item.
            </summary>
            <param name="i">The i.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.IMainWindow.stayOn">
            <summary>
            Gets a value indicating whether the selected item should [stay on].
            </summary>
            <value><c>true</c> if [stay on]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:GraphSynth.IMainWindow.FocusOnLabelEntry(System.Object)">
            <summary>
            Focuses on the label field for easy entry.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.propertyUpdate(System.Object)">
            <summary>
            Properties the update.
            </summary>
            <param name="o">The o.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.SetCanvasPropertyScaleFactor(System.Double,System.Nullable{System.Boolean})">
            <summary>
            Sets the canvas property scale factor. This is needed since the
            GraphGUI needs to inform the main window what its scale is. The
            reason it is defined here, is because GraphGUI is defined in the
            CustomControls.dll and MainWindow is in the main EXE. Thus, we
            can make a call up from a dependent library to the main EXE.
            </summary>
            <param name="scale">The scale.</param>
            <param name="zoomToFit">The zoom to fit.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.addAndShowGraphWindow(System.Object,System.String)">
            <summary>
            Adds and shows a graph window.
            </summary>
            <param name="obj">The obj.</param>
            <param name="title">The title.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.addAndShowRuleWindow(System.Object,System.String)">
            <summary>
            Adds and shows a rule window.
            </summary>
            <param name="obj">The obj.</param>
            <param name="title">The title.</param>
        </member>
        <member name="M:GraphSynth.IMainWindow.addAndShowRuleSetWindow(System.Object,System.String)">
            <summary>
            Adds and shows a rule window.
            </summary>
            <param name="obj">The obj.</param>
            <param name="title">The title.</param>
        </member>
        <member name="T:GraphSynth.SearchIO">
            <summary>
              The static class that handles input and output statements from a
              Search Process.
            </summary>
        </member>
        <member name="P:GraphSynth.SearchIO.iteration">
            <summary>
              Gets or sets the iteration.
            </summary>
            <value>The iteration.</value>
        </member>
        <member name="M:GraphSynth.SearchIO.getIteration(System.Int32)">
            <summary>
            Gets the iteration.
            </summary>
            <param name="threadID">The thread identifier.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.SearchIO.miscObject">
            <summary>
              Gets or sets the misc object.
            </summary>
            <value>The misc object.</value>
        </member>
        <member name="M:GraphSynth.SearchIO.getMiscObject(System.Int32)">
            <summary>
              Gets the misc object.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.SearchIO.terminateRequest">
            <summary>
              Gets a value indicating whether [terminate request].
            </summary>
            <value><c>true</c> if [terminate request]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:GraphSynth.SearchIO.GetTerminateRequest(System.Int32)">
            <summary>
            Gets the Boolean indicating whether a termination request has been sent.
            </summary>
            <param name="searchThreadName">Name of the search thread.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.setTerminationRequest(System.Int32)">
            <summary>
              Sets the termination request.
            </summary>
            <param name = "threadName">Name of the thread.</param>
        </member>
        <member name="P:GraphSynth.SearchIO.timeInterval">
            <summary>
              Gets the time interval.
            </summary>
            <value>The time interval.</value>
        </member>
        <member name="M:GraphSynth.SearchIO.setTimeInterval(System.Int32,System.TimeSpan)">
            <summary>
              Sets the time interval.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <param name = "value">The value.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.getTimeInterval(System.Int32)">
            <summary>
              Gets the time interval.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <returns></returns>
        </member>
        <member name="F:GraphSynth.SearchIO.defaultVerbosity">
            <summary>
              Defines the default verbosity of all search threads.
            </summary>
        </member>
        <member name="P:GraphSynth.SearchIO.verbosity">
            <summary>
              Gets the verbosity.
            </summary>
            <value>The verbosity.</value>
        </member>
        <member name="M:GraphSynth.SearchIO.setVerbosity(System.Int32,System.Int32)">
            <summary>
              Sets the verbosity.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <param name = "value">The value.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.getVerbosity(System.Int32)">
            <summary>
              Gets the verbosity.
            </summary>
            <param name = "threadName">Name of the thread.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.output(System.Object,System.Int32)">
            <summary>
             Calling SearchIO.output will output the string, message, to the 
             text display on the right of GraphSynth, but ONLY if the verbosity (see
             below) is greater than or equal to your specified limit for this message.
             the verbosity limit must be 0, 1, 2, 3, or 4.
            </summary>
            <param name="message">The message.</param>
            <param name="verbosityLimit">The verbosity limit.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.output(System.Object[])">
            <summary>
            Outputs the one item of the specified list corresponding to the particular verbosity.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.MessageBoxShow(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Messages the box show.
            </summary>
            <param name="messageBoxText">The message box text.</param>
            <param name="caption">The caption.</param>
            <param name="iconStr">The icon string.</param>
            <param name="buttonStr">The button string.</param>
            <param name="defaultResultStr">The default result string.</param>
            <param name="optionsStr">The options string.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.SearchIO.addAndShowGraphWindow(System.Object,System.String)">
            <summary>
            Adds the and show graph window.
            </summary>
            <param name="graphObjects">The graph objects.</param>
            <param name="title">The title.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.addAndShowRuleWindow(System.Object,System.String)">
            <summary>
            Adds the and show rule window.
            </summary>
            <param name="ruleObjects">The rule objects.</param>
            <param name="title">The title.</param>
        </member>
        <member name="M:GraphSynth.SearchIO.addAndShowRuleSetWindow(System.Object,System.String)">
            <summary>
            Adds the and show rule set window.
            </summary>
            <param name="ruleObjects">The rule objects.</param>
            <param name="title">The title.</param>
        </member>
        <member name="T:GraphSynth.choiceMethods">
            <summary>
            Defines whether the choice method of a particular ruleset is done
            by some design agent (human or computer) or is automatic - meaning 
            once a rule is found to be recognized on a host, it is invoked.
            </summary>
        </member>
        <member name="F:GraphSynth.choiceMethods.Design">
            <summary>
            A set of options are first defined by an exhaustive recognition
            of all rules in the ruleset. The decision of which option to 
            choose is left to some design agent.
            </summary>
        </member>
        <member name="F:GraphSynth.choiceMethods.Automatic">
            <summary>
            Whenever a rule is recognized it is invoked. Rules invoked in 
            the order presented in the ruleset.
            </summary>
        </member>
        <member name="T:GraphSynth.feasibilityState">
            <summary>
            Defines whether the candidates created by a particular ruleset 
            are feasible candidates and hence ready for evaluation, or
            developing candidates which are yet to completed.
            </summary>
        </member>
        <member name="F:GraphSynth.feasibilityState.Unspecified">
            <summary/>
        </member>
        <member name="F:GraphSynth.feasibilityState.Developing">
            <summary>
            Candidates are not yet complete, they are still 
            developing; not ready for evaluation.
            </summary>
        </member>
        <member name="F:GraphSynth.feasibilityState.Feasible">
            <summary>
            Candidates are feasible and ready for evaluation.
            </summary>
        </member>
        <member name="T:GraphSynth.nextGenerationSteps">
            <summary>
            Defines how the generation process is to continue.
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.Unspecified">
            <summary />
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.Stop">
            <summary>
            stop the generation process
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.Loop">
            <summary>
            loop within current ruleset
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToPrevious">
            <summary>
            go to the previous ruleset
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToNext">
            <summary>
            go to the next ruleset
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet0">
            <summary>
            go to ruleset #0
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet1">
            <summary>
            go to ruleset #1
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet2">
            <summary>
            go to ruleset #2
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet3">
            <summary>
            go to ruleset #3
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet4">
            <summary>
            go to ruleset #4
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet5">
            <summary>
            go to ruleset #5
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet6">
            <summary>
            go to ruleset #6
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet7">
            <summary>
            go to ruleset #7
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet8">
            <summary>
            go to ruleset #8
            </summary>
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet9">
            <summary>
            go to ruleset #9
            </summary> 
        </member>
        <member name="F:GraphSynth.nextGenerationSteps.GoToRuleSet10">
            <summary>
            go to ruleset #10
            </summary>
        </member>
        <member name="T:GraphSynth.GenerationStatuses">
            <summary>
            Enumerator Declaration for How Generation Ended, GenerationStatus 
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.Unspecified">
            <summary />
        </member>
        <member name="F:GraphSynth.GenerationStatuses.Normal">
            <summary>
            Following a normal cycle through the RCA loop.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.Choice">
            <summary>
            Following the choosing step of the RCA loop.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.CycleLimit">
            <summary>
            Following the a maximum number of cycle through the RCA loop.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.NoRules">
            <summary>
            Following no rules having been recognized.
            </summary>
        </member>
        <member name="F:GraphSynth.GenerationStatuses.TriggerRule">
            <summary>
            Following the application of a trigger rule.
            </summary>
        </member>
        <member name="T:GraphSynth.optimize">
            <summary>
             Enumerator for Search functions that have generality
             to either minimize or maximize (e.g. PNPPS, stochasticChoose). */
            </summary>
        </member>
        <member name="F:GraphSynth.optimize.minimize">
            <summary>
            Minimize in the search - smaller is better.
            </summary>
        </member>
        <member name="F:GraphSynth.optimize.maximize">
            <summary>
            Maximize in the search - bigger is better.
            </summary>
        </member>
        <member name="T:GraphSynth.ConfluenceAnalysis">
            <summary>
            Calculating the confluence between options is a complex task which may take an
            unintended amount of time to determine. In order to control this three possible
            analyses are defined. 
            </summary>
        </member>
        <member name="F:GraphSynth.ConfluenceAnalysis.ConservativeSimple">
            <summary>
            A simple analysis that may produce a number of "unknown" states. Any unknown
            states are regarded as NOT confluent, even though they may be.
            </summary>
        </member>
        <member name="F:GraphSynth.ConfluenceAnalysis.OptimisticSimple">
            <summary>
            A simple analysis that may produce a number of "unknown" states. Any unknown
            states are regarded as confluent, even though they may not be.
            </summary>
        </member>
        <member name="F:GraphSynth.ConfluenceAnalysis.Full">
            <summary>
            The full analysis will run the empirical test for invalidation between a pair
            of options. This is potentially time-consuming.
            </summary>
        </member>
        <member name="T:GraphSynth.OptimizeSort">
            <summary>
            A comparer for optimization that can be used for either 
            minimization or maximization.
            </summary>
        </member>
        <member name="M:GraphSynth.OptimizeSort.#ctor(GraphSynth.optimize,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.OptimizeSort"/> class.
            </summary>
            <param name="direction">The direction.</param>
            <param name="AllowEqualInSort">The allow equal in sort.</param>
        </member>
        <member name="M:GraphSynth.OptimizeSort.Compare(System.Double,System.Double)">
            <summary>
            Compares two objects and returns a value indicating whether the 
            first one is better than the second one. "Better than" is defined
            by the optimize direction provided in the constructor. 
            </summary>
            <returns>
            A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, 
            as shown in the following table. 
            Value | Meaning 
            Less than zero | <paramref name="x"/> is less than <paramref name="y"/>.
            Zero | <paramref name="x"/> equals <paramref name="y"/>.
            Greater than zero | <paramref name="x"/> is greater than <paramref name="y"/>.
            </returns>
            <param name="x">The first object to compare.</param><param name="y">The second object to compare.</param>
        </member>
        <member name="M:GraphSynth.OptimizeSort.BetterThan(System.Double,System.Double)">
            <summary>
            Is x betters the than y?
            </summary>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.transfromType">
            <summary>
            Defines the constraint on how shapes/coordinates are transformed. 
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.Prohibited">
            <summary>
            This type of transform is not recognized/performed.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.OnlyX">
            <summary>
            This type of transform is recognized/performed only in the X-direction.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.OnlyY">
            <summary>
            This type of transform is recognized/performed only in the Y-direction.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.OnlyZ">
            <summary>
            This type of transform is recognized/performed only in the Z-direction.
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.XYZUniform">
            <summary>
            This type of transform is recognized/performed uniformly in X, Y, and Z.
            </summary>  
        </member>
        <member name="F:GraphSynth.transfromType.BothUniform">
            <summary>        
            Deprecated. The type of transform is recognized/performed uniformly in BOTH X and Y (should use XYZUniform).
            </summary>
        </member>
        <member name="F:GraphSynth.transfromType.XYZIndependent">
            <summary>
            This type of transform is recognized/performed independently in X, Y, and Z.
            </summary>    
        </member>
        <member name="F:GraphSynth.transfromType.BothIndependent">
            <summary>        
            Deprecated. The type of transform is recognized/performed independently in BOTH X and Y (should use XYZIndependent).
            </summary>
        </member>
        <member name="T:GraphSynth.MyIOPath">
            <summary>
              A simple static class created within a single function - to create relative paths.
            </summary>
        </member>
        <member name="M:GraphSynth.MyIOPath.GetRelativePath(System.String,System.String)">
            <summary>
              Gets the relative path to the target path starting at the "with Respect to" directory.
              The method will add the necessary "..\" to get back to the common directory.
            </summary>
            <param name = "target">The target path.</param>
            <param name = "withRespectTo">The "with respect to" directory.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Search.LindenmayerChooseRCA">
            <summary>
            As stated on the wikipedia page (http://en.wikipedia.org/wiki/L-system)
            "The rules of the L-system grammar are applied iteratively starting 
            from the initial state. As many rules as possible are applied 
            simultaneously, per iteration; this is the distinguishing feature 
            between an L-system and the formal language generated by a formal grammar. 
            If the production rules were to be applied only one at a time, one would 
            quite simply generate a language, rather than an L-system. Thus, 
            L-systems are strict subsets of languages."
            Thus, this is used in the RCA loop to invoke all confluent rules.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.LindenmayerChooseRCA.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified options. Given the list of options and the candidate,
            determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.LindenmayerChooseRCA.choose(GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified option. Given that the rule has now been chosen, determine
            the values needed by the rule to properly apply it to the candidate, cand. The
            array of double is to be determined by parametric apply rules written in
            complement C# files for the ruleSet being used.
            </summary>
            <param name="opt">The opt.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.LindenmayerChooseRCA.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Search.LindenmayerChooseRCA"/> class.
            </summary>
            <param name="seed">The seed.</param>
            <param name="rulesets">The rulesets.</param>
            <param name="numCalls">The num calls.</param>
            <param name="display">if set to <c>true</c> [display].</param>
        </member>
        <member name="T:GraphSynth.Search.RandomChooseRCA">
            <summary>
            An overload for the RCA class that randomly chooses options. 
            
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RandomChooseRCA.rnd">
            <summary>
            a random number generator to be used in choose.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseRCA.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified options. Given the list of options and the candidate,
            determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseRCA.choose(GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified option. Given that the rule has now been chosen, determine
            the values needed by the rule to properly apply it to the candidate, cand. The
            array of double is to be determined by parametric apply rules written in
            complement C# files for the ruleSet being used.
            </summary>
            <param name="opt">The opt.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseRCA.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Search.RandomChooseRCA"/> class.
            </summary>
            <param name="seed">The seed.</param>
            <param name="rulesets">The rulesets.</param>
            <param name="numCalls">The num calls.</param>
            <param name="display">if set to <c>true</c> [display].</param>
        </member>
        <member name="T:GraphSynth.Search.RandomChooseWithUndoRCA">
            <summary>
            An overload for the RCA class that randomly chooses options. In this 
            version, it can also randomly choose to undo the last option (by choosing
            -1).
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RandomChooseWithUndoRCA.rnd">
            <summary>
            a random number generator to be used in choose.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseWithUndoRCA.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
            Chooses the specified options. Given the list of options and the candidate,
            determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name="options">The options.</param>
            <param name="cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RandomChooseWithUndoRCA.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Search.RandomChooseWithUndoRCA"/> class.
            </summary>
            <param name="_seed">The _seed.</param>
            <param name="_rulesets">The _rulesets.</param>
            <param name="_maxNumOfCalls">The _max num of calls.</param>
            <param name="_display">if set to <c>true</c> [_display].</param>
        </member>
        <member name="T:GraphSynth.Search.RecognizeChooseApply">
            <summary>
              this is the main file and class of generation. The model adopted is that one should
              create an inherited class of this ABSTRACT class, as has been done for randomChoose, 
              chooseViaHumanGui, etc. This file has gone through a lot of revision to make it 
              general to a wide variety of problems. It should not have to be altered, rather one
              can control aspects of the execution through the ruleSets
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RecognizeChooseApply.Rulesets">
            <summary>
              An array of rulesets used in this generation process.
            </summary>
        </member>
        <member name="F:GraphSynth.Search.RecognizeChooseApply.NumOfRuleSets">
            <summary>
            The number of rule sets
            </summary>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.Host">
            <summary>
            Gets or sets the host. Often the same as the seed used as a starting point for the 
            generation process. That seed is stored here as a accessible propoerty of the class.
            </summary>
            <value>
            The host.
            </value>
        </member>
        <member name="F:GraphSynth.Search.RecognizeChooseApply.MaxNumOfCalls">
            <summary>
              The array of the maximum number of calls to make in each ruleset.
              This is not cumulative - if you return to a previous ruleset, the counter is 
              reset. It is copied to the numOfCallsLeft at the beginning of the RCACycle into 
              the numOfCallsLeft slot.
            </summary>
            <value>The max num of calls.</value>
        </member>
        <member name="F:GraphSynth.Search.RecognizeChooseApply.Display">
            <summary>
            A simple Boolean used for debugging or interactive generation. If true then
            the host will be replotted after each apply action.
            </summary>
            <value><c>true</c> if display; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:GraphSynth.Search.RecognizeChooseApply.InParallel">
            <summary>
            A value indicating whether [in parallel].
            </summary>
            <value><c>true</c> if [in parallel]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.RecognizeChooseApplyCycle(GraphSynth.Representation.candidate,System.Int32,System.Int32[])">
            <summary>
              Recognizes the choose apply cycle. Here is the main Recognize, Choose, and 
              Apply Generation Cycle. It accepts the host candidate (not graph), the index
              of what ruleSet to invoke, and an array of size equal to the number of ruleSets.
              At the end of the process, it returns the updated candidate. The three step
              process may, however exit at any of five places in the loop, these are described below.
              1. the ruleSet invoked may not have any calls left. This will cause the GenerationStatus
              to be CycleLimit, and the process will execute what is stored in the 3rd position of 
              generationSteps, ruleSet->nextGenerationStep[2], either Stop, Loop, GoToPrevious(ruleSet),
              GoToNext(ruleSet), or GoToRuleSet#
              2. the choice operation has sent a STOP message, or more precisely a negative # or
              a number greater than the list of option. This results in a GenerationStatus of Choice
              and the execution of ruleSet->nextGenerationStep[1] (any of the options stated above).
              3. there are no rules recognized for the graph. This results in a GenerationStatus of
              NoRules and the execution of ruleSet->nextGenerationStep[3] (any of the options above).
              4. A trigger rule has been applied. This results in a GenerationStatus of TriggerRule
              and the execution of ruleSet->nextGenerationStep[4] (any of the options stated above).
              5. the recognize, choose, and apply cycle performed as intended - no abnormal activites.
              This results in a GenerationStatus of Normal and the execution of 
              ruleSet->nextGenerationStep[0] (any of the options stated above).*/
            </summary>
            <param name = "host">The host.</param>
            <param name = "ruleSetIndex">Index of the rule set.</param>
            <param name = "numOfCallsLeft">The num of calls left.</param>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.CallOneRuleOnCandidate(GraphSynth.Representation.candidate,System.Int32)">
            <summary>
              Calls  one rule on candidate - the rule is determined by the choose function.
            </summary>
            <param name = "cand">The cand.</param>
            <param name = "startingRuleSet">The starting rule set.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.GenerateAllNeighbors(GraphSynth.Representation.candidate,System.Boolean,System.Int32)">
            <summary>
              Generates all neighbors of the current.
            </summary>
            <param name = "current">The current.</param>
            <param name = "IncludingParent">if set to <c>true</c> [including parent].</param>
            <param name = "MaxNumber">The max number.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.GenerateOneCandidate(GraphSynth.Representation.candidate,System.Int32)">
            <summary>
              Generates one candidate. A simple function for invoking the RecognizeChooseApplyCycle.
              That function is protected so we invoke it through a function like this.
            </summary>
            <param name = "cand">The cand to build upon (if null, then the seed will be used).</param>
            <param name = "startingRuleSet">The starting rule set (if unspecified then the candidate's active ruleset will be used.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.#ctor(GraphSynth.Representation.designGraph,GraphSynth.Representation.ruleSet[],System.Int32[],System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.Search.RecognizeChooseApply" /> class.
            </summary>
            <param name="host">The _seed.</param>
            <param name="rulesets">The _rulesets.</param>
            <param name="maxNumOfCalls">The _max num of calls.</param>
            <param name="display">if set to <c>true</c> [_display].</param>
            <param name="inParallel">The process should be invoked in parallel where possible.</param>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.choose(System.Collections.Generic.List{GraphSynth.Representation.option},GraphSynth.Representation.candidate)">
            <summary>
              Chooses the specified options. Given the list of options and the candidate, 
              determine what option to invoke. Return the integer index of this option from the list.
            </summary>
            <param name = "options">The options.</param>
            <param name = "cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Search.RecognizeChooseApply.choice">
            <summary>
              Gets or sets the integer choice which is used in the main loop as well as in 
              various implementation of choose. As a result we define it as global to the class.
            </summary>
            <value>The choice.</value>
        </member>
        <member name="M:GraphSynth.Search.RecognizeChooseApply.choose(GraphSynth.Representation.option,GraphSynth.Representation.candidate)">
            <summary>
              Chooses the specified option. Given that the rule has now been chosen, determine
              the values needed by the rule to properly apply it to the candidate, cand. The 
              array of doubles is to be determined by parametric apply rules written in 
              complement C# files for the ruleSet being used.
            </summary>
            <param name = "opt">The opt.</param>
            <param name = "cand">The cand.</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.Search.SearchProcess">
            <summary>
              The abstract class that must be inherited in the Search plugins.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.#ctor(GraphSynth.GlobalSettings)">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Search.SearchProcess" /> class.
            </summary>
            <param name = "settings">The settings.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:GraphSynth.Search.SearchProcess" /> class.
            </summary>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.seedGraph">
            <summary>
              Gets the seed graph defined in settings.
            </summary>
            <value>The seed graph.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.seedCandidate">
            <summary>
              Gets the seed candidate.
            </summary>
            <value>The seed candidate.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.numOfRuleSets">
            <summary>
            Gets the number of RuleSets.
            </summary>
            <value>
            The num of rule sets.
            </value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.rulesets">
            <summary>
              Gets the rulesets defined in the settings as an array.
            </summary>
            <value>The rulesets.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.RequireSeed">
            <summary>
              Gets or sets a value indicating whether [require seed].
            </summary>
            <value><c>true</c> if [require seed]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.RequiredNumRuleSets">
            <summary>
              Gets or sets the required num rule sets.
            </summary>
            <value>The required num rule sets.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.AutoPlay">
            <summary>
              Gets or sets a value indicating whether [auto play].
            </summary>
            <value><c>true</c> if [auto play]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.settings">
            <summary>
              Gets the settings defined for the problem (as saved in GraphSynthSettings.gsconfig
              and as specified by the user in Edit->Settings).
            </summary>
            <value>The settings.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.text">
            <summary>
              Gets the text describing that is displayed in the menu. It must be overridden in the methods.
            </summary>
            <value>The text.</value>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.RunSearchProcess">
            <summary>
              Runs the search process.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.Run">
            <summary>
              Runs this instance.
            </summary>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.transferLmappingToChild(GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph,GraphSynth.Representation.option)">
            <summary>
              A necessary function when multiple (more than one) application of a rule is applied
              to a host. The function reads in the child graph (often a copy of the current), 
              the current graph, and the Lmapping. The Lmapping is changed but the child and current are
              unaffected.
            </summary>
            <param name = "child">The child.</param>
            <param name = "current">The current.</param>
            <param name = "Lmapping">The lmapping.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.transferLmappingToChild(GraphSynth.Representation.designGraph,GraphSynth.Representation.designGraph,System.Collections.Generic.List{GraphSynth.Representation.node},System.Collections.Generic.List{GraphSynth.Representation.arc},System.Collections.Generic.List{GraphSynth.Representation.hyperarc})">
            <summary>
            A necessary function when multiple (more than one) application of a rule is applied
            to a host. The function reads in the child graph (often a copy of the current),
            the current graph, and the Lmapping. The Lmapping is changed but the child and current are
            unaffected.
            </summary>
            <param name="child">The child.</param>
            <param name="current">The current.</param>
            <param name="LMappedNodes">The L mapped nodes.</param>
            <param name="LMappedArcs">The L mapped arcs.</param>
            <param name="LMappedHyperarcs">The L mapped hyperarcs.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.nextRuleSet(System.Int32,GraphSynth.GenerationStatuses)">
            <summary>
              This function returns what the new ruleSet
              will be. Here the enumerator nextGenerationSteps and GenerationStatuses is used to great
              affect. Understand that if a negative number is returned, the cycle will be stopped.
            </summary>
            <param name="ruleSetIndex">Index of the rule set.</param>
            <param name="status">The status.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.NextRuleSet(GraphSynth.Representation.ruleSet[],System.Int32,GraphSynth.GenerationStatuses)">
            <summary>
            This function returns what the new ruleSet
            will be. Here the enumerator nextGenerationSteps and GenerationStatuses is used to great
            affect. Understand that if a negative number is returned, the cycle will be stopped.
            </summary>
            <param name="RuleSets">The rule sets.</param>
            <param name="ruleSetIndex">Index of the rule set.</param>
            <param name="status">The status.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.IsInheritedType(System.Type)">
            <summary>
            Determines whether [the specified type] is inherited from SearchProcess.
            </summary>
            <param name="t">The t.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.addChildToSortedCandList(System.Collections.Generic.List{GraphSynth.Representation.candidate},GraphSynth.Representation.candidate)">
            <summary>
              Adds the child to sorted candidate list based on the value of f0 (performanceParams[0]).
              The OptimizeDirection is not used as the list is always sorted from lowest to highest.
            </summary>
            <param name = "candidates">The candidates.</param>
            <param name = "child">The child.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.addNewCandtoPareto(GraphSynth.Representation.candidate,System.Collections.Generic.List{GraphSynth.Representation.candidate})">
            <summary>
              Adds the new candidate to the pareto set.
            </summary>
            <param name = "c">The c.</param>
            <param name = "ParetoCands">The pareto cands.</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.dominates(GraphSynth.Representation.candidate,GraphSynth.Representation.candidate)">
            <summary>
              Does c1 dominate c2? assuming this is a minimization of all objectives 
            </summary>
            <param name = "c1">the subject candidate, c1 (does this dominate...).</param>
            <param name = "c2">the object candidate, c2 (is dominated by).</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.dominates(GraphSynth.Representation.candidate,GraphSynth.Representation.candidate,GraphSynth.optimize[])">
            <summary>
              Does candidate, c1, dominate c2?
            </summary>
            <param name = "c1">The c1.</param>
            <param name = "c2">The c2.</param>
            <param name = "optDirections">The opt directions.</param>
            <returns></returns>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.inputDirectory">
            <summary>
            Gets or sets the input directory.
            </summary>
            <value>The input directory.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.outputDirectory">
            <summary>
            Gets or sets the output directory.
            </summary>
            <value>The output directory.</value>
        </member>
        <member name="P:GraphSynth.Search.SearchProcess.rulesDirectory">
            <summary>
            Gets or sets the rules directory.
            </summary>
            <value>The rules directory.</value>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.Save(System.String,System.Object,System.Boolean)">
            <summary>
            Saves the specified filename.
            </summary>
            <param name="filename">The filename.</param>
            <param name="o">The o.</param>
            <param name="SuppressWarnings">if set to <c>true</c> [suppress warnings].</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.SaveCandidates(System.String,System.Collections.IList,System.Boolean,System.Boolean)">
            <summary>
            Saves the candidates.
            </summary>
            <param name="filename">The filename base, a unique number is added for each
            candidate (plus the timestamp, if true).</param>
            <param name="candidates">The candidates.</param>
            <param name="SaveToOutputDir">if set to <c>true</c> [save to output dir].</param>
            <param name="timeStamp">if set to <c>true</c> [time stamp].</param>
        </member>
        <member name="M:GraphSynth.Search.SearchProcess.Open(System.String,System.Boolean)">
            <summary>
            Opens the specified filename.
            </summary>
            <param name="filename">The filename.</param>
            <param name="SuppressWarnings">if set to <c>true</c> [suppress warnings].</param>
            <returns></returns>
        </member>
        <member name="T:GraphSynth.ShapeData">
            <summary>
            The ShapeData class stores the data for how to display a particular graph element:
            node, arc, or hyperarc. At this level, it is essentially an XML string of data. It is
            similar to the GraphSynth.CustomControls.DisplayShape, which inherits from this class.
            That class is specific to the WPF viewer programs.
            This is a new class as of October 2011. It combines three previous classes (IDisplayShape,
            ShapeKey, and DisplayStringShape [from GraphSynthConsole]) into a single class.
            </summary>
        </member>
        <member name="F:GraphSynth.ShapeData.Element">
            <summary>
            The graph element that this data is representing
            </summary>
        </member>
        <member name="F:GraphSynth.ShapeData._stringShape">
            <summary>
            This protected field describes the shape.
            </summary>
        </member>
        <member name="M:GraphSynth.ShapeData.#ctor(System.String,GraphSynth.Representation.graphElement)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.ShapeData"/> class.
            </summary>
            <param name="s">The s.</param>
            <param name="element">The element.</param>
        </member>
        <member name="M:GraphSynth.ShapeData.#ctor(GraphSynth.Representation.graphElement)">
            <summary>
            Initializes a new instance of the <see cref="T:GraphSynth.ShapeData"/> class.
            </summary>
            <param name="element">The element.</param>
        </member>
        <member name="M:GraphSynth.ShapeData.op_Implicit(GraphSynth.ShapeData)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:GraphSynth.ShapeData"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="x">The ShapeData, x.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:GraphSynth.ShapeData.Copy(GraphSynth.Representation.graphElement)">
            <summary>
            Copies the specified element.
            </summary>
            <param name="element">The element.</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.ShapeData.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:GraphSynth.ShapeData.TransformMatrix">
            <summary>
            Gets or sets the transform matrix.
            </summary>
            <value>
            The transform matrix.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Fill">
            <summary>
            Gets or sets the fill.
            </summary>
            <value>
            The fill.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Stroke">
            <summary>
            Gets or sets the stroke.
            </summary>
            <value>
            The stroke.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.StrokeThickness">
            <summary>
            Gets or sets the stroke thickness.
            </summary>
            <value>
            The stroke thickness.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Height">
            <summary>
            Gets or sets the height.
            </summary>
            <value>
            The height.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Width">
            <summary>
            Gets or sets the width.
            </summary>
            <value>
            The width.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.ScreenX">
            <summary>
            Gets or sets the screen X.
            </summary>
            <value>
            The screen X.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.ScreenY">
            <summary>
            Gets or sets the screen Y.
            </summary>
            <value>
            The screen Y.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Tag">
            <summary>
            Gets or sets the tag.
            </summary>
            <value>
            The tag.
            </value>
        </member>
        <member name="P:GraphSynth.ShapeData.Shape">
            <summary>
            Gets the shape.
            </summary>
        </member>
        <member name="F:GraphSynth.MatrixMath.epsilon">
            <summary>
              This is used below in the close enough to zero booleans to match points
              (see below: sameCloseZero). In order to avoid strange round-off issues - 
              even with doubles - I have implemented this function when comparing the
              position of points (mostly in checking for a valid transformation (see
              ValidTransformation) and if other nodes comply (see otherNodesComply).
            </summary>
        </member>
        <member name="M:GraphSynth.MatrixMath.crossProduct3(System.Double[],System.Double[])">
            <summary>
            The cross product of two double vectors, A and B, which are of length, 3.
            This is equivalent to calling crossProduct, but a slight speed advantage
            may exist in skipping directly to this sub-function.
            </summary>
            <param name = "A">1D double Array, A</param>
            <param name = "B">1D double Array, B</param>
            <returns></returns>
        </member>
        <member name="M:GraphSynth.MatrixMath.norm2(System.Double[],System.Int32,System.Boolean)">
            <summary>
            Returns to 2-norm (square root of the sum of squares of all terms)
            of the vector, x.
            </summary>
            <param name="x">The vector, x.</param>
            <param name="size">The size or length of the array.</param>
            <param name="dontDoSqrt">if set to <c>true</c> [don't take the square root].</param>
            <returns>
            Scalar value of 2-norm.
            </returns>
            <exception cref="T:System.Exception">The vector, x, is null.</exception>
        </member>
    </members>
</doc>
